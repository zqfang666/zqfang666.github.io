<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java编程思想(上)</title>
      <link href="/2019/07/08/(java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%85%A0)2019.6.28%20%E4%B8%80%E8%87%B3%E4%B8%83/"/>
      <url>/2019/07/08/(java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%85%A0)2019.6.28%20%E4%B8%80%E8%87%B3%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<p>抽象类 接口<br>抽象类 接口区别<br>1，抽象类里可以有构造方法，而接口内不能有构造方法。<br>2，抽象类中可以有普通成员变量，而接口中不能有普通成员变量。<br>3，抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有<br>非抽象的普通方法。<br>4，抽象类中的抽象方法的访问类型可以是public ，protected和默认类型，但接口中的抽<br>象方法只能是public类型的，并且默认即为public abstract类型。<br>5，抽象类中可以包含静态方法，接口内不能包含静态方法。<br>6，抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可<br>以任意，但接口中定义的变量只能是public static类型，并且默认为public static类型。<br>7，一个类可以实现多个接口，但只能继承一个抽象类。</p><h2 id="Think-in-Java"><a href="#Think-in-Java" class="headerlink" title="Think in Java"></a>Think in Java</h2><h3 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章 一切都是对象"></a>第二章 一切都是对象</h3><p>2.2 基本类型<br>| 类型| 位数+范围 |<br>|–|–|<br>| boolean(Boolean) |  |<br>|char(Character)  | 16bits       0<del>2^16-1(65535)<br>|byte(Byte)   | 8bits          -128</del>127 |<br>| short(Short)  |16bits        -2^ 15(32768) ~ 2^15-1 |<br>|int(Integer)  | 32bits        -2^31(2147483648 =2*10 ^9) ~ 2 ^31-1 |<br>|long(Long) | 64bits        -2^63(9,223,372,036,854,775,808)~ 2 ^63-1           |<br>|float(Float)    | 32bits |<br>| double(Double)  |   64bits |<br>| void |  |</p><h3 id="第三章操作符"><a href="#第三章操作符" class="headerlink" title="第三章操作符"></a>第三章操作符</h3><p>3.8 逻辑操作符（p46）</p><ul><li>短路：一旦能明确无误的确定整个表达式的值，就不再计算其余部分</li></ul><pre><code> teat1(0) &amp;&amp;  teat1(0) &amp;&amp; teat1(0)</code></pre><p>3.9 直接常量（47）：<br>后缀字符标志类型：（大小）L代表long；（大小写）F代表float；D代表double。0x代表十六进制，0代表8进制，二进制通过Integer.toBinaryString()、Long.toBinaryString()</p><pre><code>        long i = 0x12;       long j = 012;       System.out.println(&quot;i=&quot;+i+&quot;二进制&quot;+Long.toBinaryString(i));       System.out.println(&quot;j=&quot;+j+&quot;二进制&quot;+Long.toBinaryString(j));</code></pre><ul><li>指数计数法</li></ul><pre><code>        float a =  1e-43f;        float fmax = Float.MAX_VALUE;        float fmin = Float.MIN_VALUE;        double dmax = Double.MAX_VALUE;        double dmin = Double.MIN_VALUE;        System.out.println(fmax);        System.out.println(fmin);        System.out.println(dmax);        System.out.println(dmin);</code></pre><p>3.10 按为操作符(49)<br>&amp;(按位与)   可与=连用<br>|(按位或)      可与=连用<br>^(按位异或)   可与=连用<br>~(按位非，一元操作符，)   不可与=连用<br>布尔类型也作为单比特值对待</p><pre><code>        int a = 0xAAAA;        int b = 0x5555;        System.out.println(a&amp;b);        System.out.println(Integer.toBinaryString(a&amp;b));        System.out.println(a|b);        System.out.println(Integer.toBinaryString(a|b));        System.out.println(a^b);        System.out.println(Integer.toBinaryString(a^b));</code></pre><p>3.11 移位操作符(49)<br>&lt;&lt;(左移) 后面补0<br>.&gt;&gt;(有符号右移) 符号+，高位插入0；符号-，高位插入1<br>.&gt;&gt;&gt;(无符号右移)高位插入0</p><ul><li><p>对char、byte、short类型移位，会先转换为int型，得到的结果也是int类型<br>（在对byte，short移位时，先转换为int进行移位，然后再截赋值给原来的值）<br>（负数的二进制是补码，原码：负数绝对值的二进制，并令最高位为1；反码：除最高位其他取反 补码：反码+1）</p><pre><code>int a = -1;      System.out.println(Integer.toBinaryString(a).length());      a&gt;&gt;&gt;=10;      System.out.println(Integer.toBinaryString(a).length());      long b =-1;      System.out.println(Long.toBinaryString(b).length());      b&gt;&gt;&gt;=10;      System.out.println(Long.toBinaryString(b).length());      short c =-1;      System.out.println(Integer.toBinaryString(c).length());      c&gt;&gt;&gt;=10;      System.out.println(Integer.toBinaryString(c).length());      byte d = -1;      System.out.println(Integer.toBinaryString(c).length());      System.out.println(Integer.toBinaryString(c&gt;&gt;&gt;10).length());</code></pre></li></ul><pre><code>习题12：所有位都是1</code></pre><p>int a = -1;<br>        a &lt;&lt;=10;<br>        System.out.println(Integer.toBinaryString(a));<br>        for(int i=0;i&lt;32;i++){<br>            a&gt;&gt;&gt;=1;<br>            System.out.println(Integer.toBinaryString(a));<br>        }</p><pre><code></code></pre><p>char c = ‘a’;<br>        System.out.println(Integer.toBinaryString(c));<br>        c+=1;<br>        System.out.println(Integer.toBinaryString(c));<br>        c = ‘b’;<br>        System.out.println(Integer.toBinaryString(c));</p><pre><code>3.12 三元操作符boolean-exp? value0 : value13.13 字符串操作符+、+=变为字符型</code></pre><p>int x=0,y=1,z=2;<br>        String s = “x,y,z”;<br>        System.out.println(s+x+y+z);<br>        s += “sssss”;<br>        System.out.println(s+(x+y+z));<br>        System.out.println(“ “+x);<br>        //int====String<br>        String a = “”+x;<br>        String b = Integer.toString(x);</p><pre><code>3.15 类型转换操作符</code></pre><p>int a =1;<br>        long b=123131231;<br>        a = (int)b;<br>        b = (long)a;</p><pre><code>3.16 截尾和舍入对于float和double，转换为int型，回直接截尾，输出整数部分；想要舍入的话，需要round方法</code></pre><p>float a = 1.734f;<br>        System.out.println((int)a);<br>        System.out.println(Math.round(a));</p><pre><code>## 第四章 控制执行流程- 4.1 if-else- 4.3 迭代while(){}do{}while()for()求素数</code></pre><p>static void sushu(){<br>        for(int i=1;i&lt;100;i++){<br>            for(int j=1;j&lt;Math.sqrt(i);j++){<br>                if(i%j==0 &amp;&amp; j!=1){<br>                    break;<br>                }else if(j+1&gt;Math.sqrt(i)){<br>                    System.out.println(i);<br>                }<br>            }<br>        }<br>    }</p><pre><code>- Foreach语法</code></pre><p>int [] a = {1,2,3,45,6};<br>        for(int x :a){<br>            System.out.println(x);<br>        }</p><pre><code>- return:1.指定方法返回什么值；2.导致当前方法的退出</code></pre><p>static int test(int testval,int begin,int end){<br>        if (end &lt; begin) {<br>            System.out.println(“error”);<br>            return 0;<br>        }<br>        if(testval&gt;=begin &amp;&amp; testval&lt;=end){<br>            return 1;<br>        }else{<br>            return -1;<br>        }<br>    }</p><pre><code>- 4.6 break和continuebreak：直接跳出整个循环；continue：跳出本次循环，进行下一次带标签的（因为有循环嵌套存在，想从多层嵌套中break或continue）continue label：中断所有的迭代，直接转到label的地方，然后继续程序break label：中断所有的迭代，直接转到label的地方，不再进入迭代</code></pre><p>int i=0;<br>        outer:<br>        while(true){<br>            System.out.println(“Outer loop”);<br>            while(true){<br>                i++;<br>                System.out.println(“i=”+i);<br>                if(i==3){<br>                    System.out.println(“continue”);<br>                    continue ;<br>                }<br>                if(i==5){<br>                    System.out.println(“continue outer”);<br>                    continue outer;<br>                }<br>                if(i==7){<br>                    System.out.println(“break”);<br>                    break ;<br>                }<br>                if(i==9){<br>                    System.out.println(“break outer”);<br>                    break outer;<br>                }</p><pre><code>        }    }</code></pre><pre><code>- fibbo</code></pre><p>static void fibbo(int n){<br>        int a=1,b=1,temp;<br>        if(n==1){<br>            System.out.println(a);<br>            return;<br>        }<br>        if(n==2){<br>            System.out.println(a);<br>            System.out.println(b);<br>            return;<br>        }<br>        System.out.println(a);<br>        System.out.println(b);<br>        for(int i=2;i&lt;n;i++){</p><pre><code>        temp = a+b;        a = b;        b = temp;        System.out.println(b);    }}</code></pre><pre><code>- 吸血鬼数字，位数偶数；1260=21*60思路1：简单暴力方法</code></pre><p>static void bloodNum(){<br>        int a,b,c,d;<br>        for(int i=1001;i&lt;9999;i++){<br>            a = i/1000;<br>            b = (i/100)%10;<br>            c = (i/10)%10;<br>            d = (i%10);<br>            test(i,a,b,c,d);<br>            test(i,a,b,d,c);<br>            test(i,b,a,c,d);<br>            test(i,b,a,d,c);<br>            test(i,a,c,b,d);<br>            test(i,a,c,d,b);<br>            test(i,c,a,b,d);<br>            test(i,c,a,d,b);<br>            test(i,a,d,c,b);<br>            test(i,a,d,b,c);<br>            test(i,d,a,c,b);<br>            test(i,d,a,b,c);<br>        }<br>    }<br>    static void test(int i,int m,int n,int x,int y){<br>        if(i == (m<em>10+n)</em>(x<em>10+y)){<br>            System.out.println(i+”=”+(m*10+n)+”</em>“+(x*10+y));<br>        }<br>    }</p><pre><code>思路2：反过来计算，找符合的两位数</code></pre><p>static void bloodNum(){<br>        for(int i=10;i&lt;100;i++){<br>            for(int j=i;j&lt;100;j++){<br>                int target = i*j;<br>                if(target&lt;1000||target&gt;9999){<br>                    continue;<br>                }<br>                int [] tar = {target/1000,target/100%10,target/10% 10,target%10};<br>                int [] get = {i/10,i%10,j/10,j%10};<br>                Arrays.sort(tar);<br>                Arrays.sort(get);<br>                if(Arrays.equals(tar,get)){<br>                    System.out.println(target);<br>                }</p><pre><code>        }    }}</code></pre><pre><code>## 第五章、初始化与清理- 5.1 用构造器确保初始化构造器采用与类相同的名字，初始化期间自动调用构造器。无参构造器(默认构造器)：不接受任何参数- 5.2 方法重载相同名字的方法，参数不一样，每个都是独一无二的参数类型列表，(顺序不同也会区分)**基本类型的重载**：如果实际参数类型&lt;小于方法中声明的形参类型，实际会被提升；char型略有不同，会被直接提升至int型。如果实际参数类型&gt;方法中声明的形参类型，需要自己进行窄化转换。- 5.3默认构造器如果没有定义构造器，对象会自动生成一个无参构造器，并调用。</code></pre><p>Dog d = new Dog();<br>        byte a=0;<br>        short b=0;<br>        d.bark();<br>        d.bark(‘c’);<br>        d.bark(a);<br>        d.bark(b);<br>        d.bark(1);<br>        d.bark(1.0f);<br>        d.bark(1.0);</p><p>class Dog{</p><pre><code>void bark(){System.out.println(&quot;voidbark&quot;);}void bark(char c){System.out.println(&quot;char&quot;);}void bark(byte c){System.out.println(&quot;byte&quot;);}void bark(short c){System.out.println(&quot;short&quot;);}void bark(int c){System.out.println(&quot;int&quot;);}void bark(long c){System.out.println(&quot;long&quot;);}void bark(float c){System.out.println(&quot;float&quot;);}void bark(double c){System.out.println(&quot;double&quot;);}</code></pre><p>}</p><pre><code>- 5.4 this关键字对于同一个类的两个对象，如何知道是那个调用了方法：</code></pre><p>//编译器内部解决<br>Dog.function(引用,参数)</p><pre><code>this：只能在方法内部使用，表示对“**调用方法的那个对象**”的引用</code></pre><p>class Apple{<br>    void a(){<br>        System.out.println(“functiona”);<br>    }<br>    void b(){<br>        System.out.println(“this-a”);<br>        this.a();<br>        a();<br>    }<br>}</p><pre><code>构造器中调用构造器</code></pre><p>class flower{<br>    int count=0;<br>    String s = “initial”;</p><pre><code>flower(int p){    count = p;    System.out.println(&quot;coun=&quot;+count);}flower(String ss){    System.out.println(&quot;string=&quot;+s);    s=ss;}flower(String s,int p){    this(p);    //this(s);  构造器只能调用一次    this.s = s;    System.out.println(&quot;String+int&quot;);}flower(){    this(&quot;hi&quot;,7);}void pringfun(){   // this(11);  其他方法不能调用构造器    System.out.println(&quot;function pppppppp&quot;);}</code></pre><p>}</p><pre><code>- static 含义：没有this的方法。可以不建立对象，通过类调用方法，static方法内不能用非静态方法。- 5.5 终结处理和垃圾回收finalize:对象可能不被垃圾回收垃圾回收不等于“析构”</code></pre><p>Book a = new Book(true);<br>        a.checkIn();<br>        new Book(true).checkIn();<br>        System.gc();</p><p>class Book{<br>    boolean check = false;<br>    Book(boolean x){<br>        check = x;<br>    }<br>    void checkIn(){<br>        check = false;<br>    }</p><pre><code>@Overrideprotected void finalize() throws Throwable {    if(check){        System.out.println(&quot;error:checkout&quot;);    }}</code></pre><p>}</p><pre><code>Java GC：GC Root(虚拟机中引用对象+方法区中的类静态属性+方法区中常量的引用对象+本地方法栈中引用对象)从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活对象- 算法1、 停止赋值（stop and copy）（垃圾多的话效率高）——适合新生代GC2、 标记清扫（mark and sweep）（对于少量垃圾效率高，但是会产生过多碎片）3、 标记整理（Mark-compact）新生代(Young)：eden+survivor1+survivor2=8:1:1——Minor GC(复制算法)老年代(Old)：存放经过多次Minor GC存活下来的对象——Full GC(标记)OOM(out of memory)：当GC+非GC时间&gt;GCTimeRatio 限制引发- 5.6成员初始化(Java中所有变量使用前都尽量初始化)方法中的局部变量如果没有初始化会报错；而类的数据成员会自动给初始值。- 5.7构造器初始化变量先初始化，初始化先静态对象，后非静态，静态对象只初始化一次，非静态对象每次都会调用。对象创建过程：查找类路径定位.class文件；载入文件进行初始化，只在对象首次加载时进行；new XX() 在堆上为对象分配空间；存储空间清零，所有对象自动成为默认值；执行初始化动作；执行构造器。初始化的顺序</code></pre><p>public class Chapter5 {<br>    public static void main(String[] args){<br>    System.out.println(“inside main”);<br>//        Cups.cup1.f(99);<br>    }<br>    static Cups cups1 = new Cups();<br>    static Cups cups2 = new Cups();<br>}</p><p>class Cup{<br>    Cup(int x){<br>        System.out.println(“Cup(“+x+”)cup”);<br>    }<br>    void f(int x){<br>        System.out.println(“f(“+x+”)”);<br>    }<br>}</p><p>class Cups{<br>    static Cup cup1;<br>    static Cup cup2;</p><pre><code>static {    cup1 = new Cup(1);    cup2 = new Cup(2);}Cups(){    System.out.println(&quot;cups()&quot;);}</code></pre><p>}</p><pre><code>- 5.8 数组初始化数组相等，只是针对引用的复制。</code></pre><pre><code>    int [] a1;    int a[];</code></pre><pre><code>可变参数列表：</code></pre><p>static void printArray(Object… args){<br>        for(Object x :args)<br>            System.out.println(x);</p><pre><code>}</code></pre><p>static void pring(Object [] args){<br>        for(Object x :args)<br>            System.out.print(x+” “);<br>        System.out.println();<br>    }</p><pre><code>static void F(int require,String... orgs){    for(String s:orgs){        System.out.print(s);    }    System.out.println();}</code></pre><p>printArray(47,3.14f,11.11);<br>        printArray(new Integer(34),new Float(3.13),new Double(11.11));<br>        printArray(“one “,”two”,”three”);<br>        printArray(new Chapter5(),new Chapter5());<br>        pring(new Object[]{47,3.14f,11.11});</p><pre><code>    F(3,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);</code></pre><pre><code>重载的话，所有版本上都有可变参数列表，或者就不用</code></pre><p>A(1,’b’,’a’);<br>        A(‘a’,’b’);//报错</p><p>static void A(float a,Character…args){<br>        System.out.println(“first”);<br>    }</p><pre><code>static void A(Character...args){    System.out.println(&quot;second&quot;);}</code></pre><pre><code>- 5.9 枚举类型</code></pre><p>   Chapter5 a = new Chapter5(Money.E);<br>        Chapter5 b = new Chapter5(Money.Q);<br>        a.sw();<br>        b.sw();</p><pre><code>}Money degree;Chapter5(Money x){    this.degree = x;}public void sw(){    System.out.println(&quot;switch&quot;);    switch (degree){        case Q:System.out.println(&quot;Its q&quot;);break;        case W:System.out.println(&quot;Its w&quot;);break;        case E:System.out.println(&quot;Its e&quot;);break;        case R:System.out.println(&quot;Its r&quot;);break;        case T:System.out.println(&quot;Its t&quot;);break;    }}public enum Sp{    A,B,C,D}public enum Money{    Q,W,E,R,T,Y}</code></pre><pre><code>## 第六章、访问权限控制public_protected_(default)_private 权限由大至小包内含有一组类，每个类只能含有一个public类&lt;table&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;&lt;/th&gt;            &lt;th&gt;类内部&lt;/th&gt;            &lt;th&gt;同一package&lt;/th&gt;            &lt;th&gt;子类&lt;/th&gt;            &lt;th&gt;任何地方&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;tr&gt;            &lt;td&gt;private&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;default&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;protected&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;            &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;public&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;            &lt;td&gt;可以&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;## 第七章、复用类（分文组合和继承的方法）- 1.组合（在新的类中产生现有类的对象）</code></pre><p>public class Chapter7 {<br>    private Ano e;<br>    private String a,b;</p><pre><code>Chapter7(){    a = &quot;AAAAA&quot;;    b = &quot;BBBBB&quot;;}@Overridepublic String toString() {    if(e == null){        e = new Ano();    }    return &quot;A=&quot;+a+            &quot;B=&quot;+b+            &quot;e=&quot;+e;}public static void main(String[] args){    Chapter7 x = new Chapter7();    System.out.println(x);}</code></pre><p>}<br>class Ano {<br>    private String s;<br>    Ano(){<br>        System.out.println(“Ano construct”);<br>        s = “IIIIIII”;<br>    }</p><pre><code>@Overridepublic String toString() {    return s;}</code></pre><p>}</p><pre><code>- 2.继承（按照现有类的类型来创建新类） 每个类都可以有自己的main方法。</code></pre><p>class Cleaner{<br>    private String s = “cleaner”;<br>    public void append(String a){s+=a;}<br>    public void dilute(){append(“dilute”);}<br>    public void scrum(){append(“scrum”);}<br>    public void apply(){append(“apply”);}</p><pre><code>@Overridepublic String toString() {    return s;}public static void main(String[] args){    Cleaner x = new Cleaner();    x.apply();x.dilute();x.scrum();    System.out.println(x);}</code></pre><p>}</p><p>public class Chapter7 extends Cleaner{<br>@Override<br>    public void apply() {<br>        append(“new apply”);<br>        super.apply();</p><pre><code>}public void foam(){    append(&quot;foam&quot;);}public static void main(String[] args){    Chapter7 x = new Chapter7();    x.apply();    x.dilute();    x.foam();    System.out.println(x);    Cleaner.main(args);}</code></pre><p>  }</p><pre><code>基类构造器总是会被调用，在导出类构造器调用前被调用。。另外对于带参数的构造器，子类需要手动调用父类的构造器，因为自己写了带参数的构造器，就不会生成默认的不带参构造器。- 3.代理属于组合与继承之间的方法，直接在类中新建一个成员对象，然后调用成员对象的方法。- 4.结合使用组合和继承名称的重载</code></pre><p>class Chongzai{<br>    char fun(char c){<br>        System.out.println(“Char fun”);<br>        return c;<br>    }<br>    int fun(int c){<br>        System.out.println(“Int fun”);<br>        return c;<br>    }<br>    float fun(float c){<br>        System.out.println(“Float fun”);<br>        return c;<br>    }</p><p>}<br>class A extends Chongzai{<br>    String fun(String x){<br>        System.out.println(“string a”);</p><pre><code>    return  x;}public static void main(String[] args){    A x = new A();    System.out.println(x.fun(&#39;a&#39;));    System.out.println(x.fun(&quot;abc&quot;));}</code></pre><p>}</p><pre><code>- 5、两者之间的关系组合是显示地做，适用于想在新类中使用现有类的功能，而非他的接口。即在新类中嵌入某个对象让其实现功能。然后再对于新类定义一些接口。- 6、protected 关键字（类的继承者可以访问，同一包内可以访问，对于其他的还是private） - 7 向上转型</code></pre><p>class Amp{<br>    public void play(){System.out.println(“play asd”);}<br>    static void ht(Amp x){<br>        x.play();<br>    }<br>    void eat(){System.out.println(“Amp eat”);}<br>}</p><p>class Ampa extends Amp{</p><pre><code>public static void main(String[] args){    Ampa x = new Ampa();</code></pre><p>//        Amp.ht(x);<br>        Amp y = new Amp();<br>        x.play();<br>        x.grow(x);<br>        y.grow(x);//不能向下转型</p><pre><code>}static void grow(Amp x){    System.out.println(&quot;Ampa grow&quot;);    x.eat();}@Overridepublic void play() {    System.out.println(&quot;new play&quot;);}</code></pre><p>}</p><pre><code>####  8.Final关键字1. **final数据** （final   以及  static final 的区别）**如果修饰引用对象，引用对象的属性可以改变，而修饰基本类型才是不可改变****static 说明只有一份，对于同一个类的不同对象，只会有这一个，final static 命名格式VAL_5****final说明值是不可改变的，但是不同对象还是会生成不同的final值**</code></pre><p>class FinalData{<br>    private static Random rand = new Random(47);<br>    private String id;<br>    public FinalData(String s){this.id = s;}<br>    //对于static final变量命名需要大写</p><pre><code>private final int valueOne = 9;private static final int VALUE_TWO = 99;public static final int VALUE_THREE = 39;private final int i4 = rand.nextInt(20);static final int INT_5 = rand.nextInt(10);private Value v1 = new Value(22);private final Value v2 = new Value(11);private static final Value VAL_3 = new Value(33);//数组private final int[] a = {1,2,3,4,5};@Overridepublic String toString() {    return id+&quot;:&quot;+&quot;i4=&quot;+i4+&quot;,INT_5=&quot;+INT_5;}public static void main(String[] args){    FinalData x = new FinalData(&quot;x&quot;);    x.a[0]++;    x.v2.i++;  //可以对引用类型的内部改变    x.v1 = new Value(9);</code></pre><p>//        x.VAL_3 = new Value(9); //final 类型<br>//        x.v2 = new Value(8);  //v2是final类型<br>//        x.a = new int[3]; //数组的引用是不可以改变的</p><pre><code>    //对于变量随机赋值，不同的对象非静态的值不一样，但是静态的值只初始化一次，不会再改变了    System.out.println(x);    FinalData y = new FinalData(&quot;y&quot;);    System.out.println(x);    System.out.println(y);}</code></pre><p>}</p><p>class Value{<br>    int i;<br>    public Value(int i){<br>        this.i = i;<br>    }<br>}</p><pre><code>**空白final**：必须在构造器处初始化</code></pre><p>class Pop{<br>    private  int i;<br>    Pop(int i){<br>        this.i = i;<br>    }<br>}<br>class BlankFinal{<br>    private final int a;<br>    private final Pop p;</p><pre><code>public BlankFinal(){    a=1;    p = new Pop(1);}public BlankFinal(int x){    a=x;    p = new Pop(x);}public static void main(String[] args){    new BlankFinal();}</code></pre><p>}</p><pre><code>**final参数**：在方法内不可改变2. **final方法**: 把方法锁定，继承类就不可以修改了，等于private方法3. **final类**：不希望可以被继承，不需要改变。不过类中的变量可变，方法都相当于加了final- 初始化及类的加载：1.找到x.main()，找到x的编译代码(x.class文件下)，注意到他还有个基类，对基类进行加载，不管是否调用对象这些都要加载。2.基类中的static初始化，然后是导出类的static3.最后是构造器进行。</code></pre><p>class A{</p><pre><code>static int j =printInt(&quot;A.Initialized&quot;);static int printInt(String s){    System.out.println(s);    return 12;}A(){System.out.println(&quot;A construct&quot;);}</code></pre><p>}<br>class B extends A{<br>    static int k = printInt(“B.initialized”);<br>    B(){System.out.println(“B Construct”);}<br>}<br>class C{<br>    static int j =printInt(“C.Initialized”);</p><pre><code>C(){System.out.println(&quot;c construct&quot;);}static A a =new A();static int printInt(String s){    System.out.println(s);    return 12;}</code></pre><p>}</p><p>class H extends B{<br>    H(){System.out.println(“H construct”);}<br>    static int i = printInt(“H initialized”);<br>    public static void main(String[] args){</p><pre><code>    System.out.println(&quot;start&quot;);    H x = new H();    System.out.println(C.a);}</code></pre><p>}</p><p>///////////////////////////////////////////////////////////////输出<br>A.Initialized<br>B.initialized<br>H initialized            所有的基类都会进行初始化<br>start<br>A construct<br>B Construct<br>H construct              新建对象，基类对象构造器先调用<br>C.Initialized<br>A construct<br>ThinkinJava.A@4554617c</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期实习面经（19年3月至19年4月）</title>
      <link href="/2019/05/24/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%EF%BC%8819%E5%B9%B43%E6%9C%88%20%E8%87%B3%2019%E5%B9%B44%E6%9C%88%EF%BC%89/"/>
      <url>/2019/05/24/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%EF%BC%8819%E5%B9%B43%E6%9C%88%20%E8%87%B3%2019%E5%B9%B44%E6%9C%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-4-1-蘑菇街-东方财富"><a href="#2019-4-1-蘑菇街-东方财富" class="headerlink" title="2019.4.1 蘑菇街+东方财富"></a>2019.4.1 蘑菇街+东方财富</h1><h3 id="项目中是否用到多线程"><a href="#项目中是否用到多线程" class="headerlink" title="项目中是否用到多线程"></a>项目中是否用到多线程</h3><h3 id="秒杀系统内部如何实现redis与mysql的同步"><a href="#秒杀系统内部如何实现redis与mysql的同步" class="headerlink" title="秒杀系统内部如何实现redis与mysql的同步"></a>秒杀系统内部如何实现redis与mysql的同步</h3><h3 id="对于分布式的了解："><a href="#对于分布式的了解：" class="headerlink" title="对于分布式的了解："></a>对于分布式的了解：</h3><h3 id="讲讲Java中的长短连接（可以实现以下）"><a href="#讲讲Java中的长短连接（可以实现以下）" class="headerlink" title="讲讲Java中的长短连接（可以实现以下）"></a>讲讲Java中的长短连接（<a href="https://baike.baidu.com/item/socket/281150?fr=aladdin" target="_blank" rel="noopener">可以实现以下</a>）</h3><ul><li>长连接、短链接（Socket实现）  http长短连接适合的<pre><code> 长：客户端服务端只用一个socket，长期保持 适合于：适合点对点通信，点对点通信；数据库的连接就是长连接； 长连接通过心跳包来实现保活、断线</code></pre></li></ul><ul><li>短：每次请求，都新建一个socket<br>web网站的服务器都是短链接，因为上万个请求要处理，同时都是长连接的话，并发量大。</li></ul><p>（已解决）</p><h3 id="线程join方法："><a href="#线程join方法：" class="headerlink" title="线程join方法："></a>线程join方法：</h3><p><img src="https://img-blog.csdnimg.cn/201904012246357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Java内存模型（JMM）："><a href="#Java内存模型（JMM）：" class="headerlink" title="Java内存模型（JMM）："></a>Java内存模型（JMM）：</h3><ul><li>作用：定义程序中各个变量的访问规则，在JVM中将变量存储到内存中和从内存中取出变量这样的底层细节。</li><li>分布：所有的变量都存储在主内存（Main Memory）中；每个线程有自己的工作内存（Working Memory），<br><strong>工作内存</strong>（高速缓存、寄存器） 中保存了该线程使用的变量的主内存的副本拷贝，线程对变量的所有操作都是在工作内存中进行，而不是直接读写主内存的（volatile任然有工作内存，但是内部机制像是主存读取）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间的传递都需要通过主内存。</li></ul><p>建立围绕着“原子性”(操作要么全部执行要么全部不执行)、“可见性”（线程对共享变量修改，其他立马可以看到）、“有序性”</p><p><img src="https://img-blog.csdnimg.cn/20190406225913760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="秒杀系统（如何处理高并发问题）"><a href="#秒杀系统（如何处理高并发问题）" class="headerlink" title="秒杀系统（如何处理高并发问题）"></a>秒杀系统（如何处理高并发问题）</h3><p>稳：保证秒杀活动顺利完成，即秒杀商品顺利地卖出去<br>准：数据的一致性<br>快：说系统的性能要足够高，否则你怎么支撑这么大的流量呢？不光是服务端要做极致的性能优化，而且在整个请求链路上都要做协同的优化，每个地方快一点，整个系统就完美了。</p><ul><li><p>业务：卖家查询、买家下订单</p></li><li><p>前端浏览器秒杀页面=》中间代理服务=》后端服务层=》数据库层</p></li><li><p>前端：<br>1、静态资源缓存 </p><p>页面静态化<br>CDN页面缓存，也可以用redis缓存渲染的页面<br>2、限流方法</p></li></ul><p>使用验证码，防止机器人、爬虫以及分散用户请求<br>禁止重复提交 ：用户提交之后按钮置灰，禁止重复提交 </p><ul><li>服务层:</li></ul><p>1.业务分离:将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。</p><p>2.采用消息队列缓存请求：将大流量请求写到消息队列缓存，利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求，数据库层订阅消息减库存，减库存成功的请求返回秒杀成功，失败的返回秒杀结束。</p><p>3.利用缓存应对读请求：对于读多写少业务，大部分请求是查询请求，所以可以读写分离，利用缓存分担数据库压力。</p><p>4.利用缓存应对写请求：缓存也是可以应对写请求的，可把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。</p><h3 id="hashmap-中-key相等怎么办"><a href="#hashmap-中-key相等怎么办" class="headerlink" title="hashmap 中 key相等怎么办"></a><a href="https://blog.csdn.net/intersting/article/details/72627353" target="_blank" rel="noopener">hashmap 中 key相等怎么办</a></h3><p>考察理解hashmap的取值的流程，先通过hashcode找，再由equals去找<br>重写equals hashcode </p><h3 id="Maven的基本命令"><a href="#Maven的基本命令" class="headerlink" title="Maven的基本命令"></a>Maven的基本命令</h3><h3 id="第一个项目搞懂："><a href="#第一个项目搞懂：" class="headerlink" title="第一个项目搞懂："></a>第一个项目搞懂：</h3><ol><li><p>srevice（生产计划，派工单，设备，原材料） 写各种服务接口，包括各种方法<br><img src="https://img-blog.csdnimg.cn/20190407220112781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>ServiceImpl 写各种服务的实现类<br><img src="https://img-blog.csdnimg.cn/20190407220716600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>sql语言写好后通过——getListBySQLToMap来解决<br><img src="https://img-blog.csdnimg.cn/20190407221104402.png" alt="在这里插入图片描述"><br>sessionFactory 属于Hibernate对JDBC进行了非常轻量级的对象封装，<br>session表示应用程序和数据库的一次交互；包含了一般的持久化方法（CRUD）；<br>createSQLQuery 获取 Query对象     query.list获得查找结果</p></li><li><p>——rest文件</p></li></ol><p>注解实现（SpringMVC）</p><ul><li><p>@RestController 是@controller和@responsebody的结合，返回的是一个JSON对象 。@controller是返回视图，</p></li><li><p>@Resource</p></li><li><p>@RequestMapping  调用该方法的路径，以及请求方法get、post</p></li></ul><h3 id="分页的实现"><a href="#分页的实现" class="headerlink" title="分页的实现"></a>分页的实现</h3><p>写一个 PageQEntity 实体类。<br><img src="https://img-blog.csdnimg.cn/20190419225512556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="jdbc-mybatis-hibernate各自优缺点及区别："><a href="#jdbc-mybatis-hibernate各自优缺点及区别：" class="headerlink" title="jdbc,mybatis,hibernate各自优缺点及区别："></a>jdbc,mybatis,hibernate各自优缺点及区别：</h3><ol><li><p>JDBC：<br>我们平时使用jdbc进行编程，大致需要下面几个步骤：<br>1，使用jdbc编程需要连接数据库，注册驱动和数据库信息<br>2，操作Connection，打开Statement对象<br>3，通过Statement对象执行SQL，返回结果到ResultSet对象<br>4，使用ResultSet读取数据，然后通过代码转化为具体的POJO对象<br>5，关闭数据库相关的资源<br>jdbc的缺点：<br>一：工作量比较大，需要连接，然后处理jdbc底层事务，处理数据类型，还需要操作Connection，Statement对象和ResultSet对象去拿数据并关闭他们。<br>二：我们对jdbc编程可能产生的异常进行捕捉处理并正确关闭资源</p></li><li><p>Hibernate：<br> Hibernate是建立在若干POJO通过xml映射文件（或注解）提供的规则映射到数据库表上的。我们可以通过POJO直接操作数据库的数据，他提供的是一种全表映射的模型。相对而言，Hibernate对JDBC的封装程度还是比较高的，我们已经不需要写SQL，只要使用HQL语言就可以了。<br> 使用Hibernate进行编程有以下好处：<br> 1，消除了代码的映射规则，它全部分离到了xml或者注解里面去配置。<br> 2，无需在管理数据库连接，它也配置到xml里面了。<br> 3，一个会话中不需要操作多个对象，只需要操作Session对象。<br> 4，关闭资源只需要关闭一个Session便可。<br> 这就是Hibernate的优势，在配置了映射文件和数据库连接文件后，Hibernate就可以通过<strong>Session操作，非常容易，消除了jdbc带来的大量代码，大大提高了编程的简易性和可读性</strong>。Hibernate还提供了级联，缓存，映射，一对多等功能。Hibernate是全表映射，通过HQL去操作pojo进而操作数据库的数据。</p><p> Hibernate的缺点：<br> 1，全表映射带来的不便，比如更新时需要发送所有的字段。<br> 2，无法根据不同的条件组装不同的SQL。<br> 3，对多表关联和复杂的sql查询支持较差，需要自己写sql，返回后，需要自己将数据封装为pojo。<br> 4，不能有效的支持存储过程。<br> 5，虽然有HQL，但是性能较差，大型互联网系统往往需要优化sql，而hibernate做不到。</p></li><li><p>Mybatis：<br> 为了解决Hibernate的不足，Mybatis出现了，Mybatis是半自动的框架。之所以称它为半自动，是因为它需要手工匹配提供POJO，sql和映射关系，而全表映射的Hibernate只需要提供pojo和映射关系即可。<br>Mybatis需要提供的映射文件包含了一下三个部分：sql，映射规则，pojo。在Mybatis里面你需要自己编写sql，虽然比Hibernate配置多，但是Mybatis可以配置动态sql，解决了hibernate表名根据时间变化，不同条件下列不一样的问题，同时你也可以对sql进行优化，通过配置决定你的sql映射规则，也能支持存储过程，所以对于一些复杂和需要优化性能的sql查询它就更加方便。Mybatis几乎可以做到jdbc所有能做到的事情。</p></li><li><p>区别<br>1）从<strong>层次</strong>上看，JDBC是较底层的持久层操作方式，而Hibernate和MyBatis都是在JDBC的基础上进行了封装使其更加方便程序员对持久层的操作。<br>2）从<strong>功能</strong>上看，JDBC就是简单的建立数据库连接，然后创建statement，将sql语句传给statement去执行，如果是有返回结果的查询语句，会将查询结果放到ResultSet对象中，通过对ResultSet对象的遍历操作来获取数据；Hibernate是将数据库中的数据表映射为持久层的Java对象，对sql语句进行修改和优化比较困难；MyBatis是将sql语句中的输入参数和输出参数映射为java对象，sql修改和优化比较方便.<br>3）从<strong>使用</strong>上看，如果进行底层编程，而且对性能要求极高的话，应该采用JDBC的方式；如果要对数据库进行完整性控制的话建议使用Hibernate；如果要灵活使用sql语句的话建议采用MyBatis框架。</p></li></ol><h5 id="AJAX请求："><a href="#AJAX请求：" class="headerlink" title="AJAX请求："></a>AJAX请求：</h5><p><img src="https://img-blog.csdnimg.cn/20190407215913653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="4-2-深圳小公司"><a href="#4-2-深圳小公司" class="headerlink" title="4.2 深圳小公司"></a>4.2 深圳小公司</h1><h3 id="框架的认识-："><a href="#框架的认识-：" class="headerlink" title="框架的认识 ："></a>框架的认识 ：</h3><ul><li>Dao层：数据持久层，负责与数据库连接的任务封装在此。DAO层的设计首先是设计DAO的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。 （数据库访问层）</li></ul><ul><li><p>Service层：Service层主要负责业务模块的逻辑应用设计。（业务层）</p></li><li><p>Controller层:Controller层负责具体的业务模块流程的控制，在此层里面要调用Serice层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行（轻业务逻辑——参数检验，可以轻易更换接口类型）</p></li></ul><p>接口属于哪一层：</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><strong>MVC</strong></h3><p>Model：模型承载数据，并对用户提交请求进行计算。一类：数据承载Bean；一类：业务处理Bean（service、Dao）；<br>View：视图，实现用户交互。（JSP）<br>Controller：控制器，用于将用户请求转发给相应的Model进行处理，处理model结果向用户响应<br><img src="https://img-blog.csdnimg.cn/20190417172948971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="SSM（SpringMVC-Spring-MyBatis）与SSH（Struts2-Hibernate-Spring）"><a href="#SSM（SpringMVC-Spring-MyBatis）与SSH（Struts2-Hibernate-Spring）" class="headerlink" title="SSM（SpringMVC+Spring+MyBatis）与SSH（Struts2+Hibernate+Spring）"></a>SSM（SpringMVC+Spring+MyBatis）与SSH（Struts2+Hibernate+Spring）</h3><p>SSM下的开发流程：<br>1.先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。<br>2.写Mapper.xml（Mybatis），其中定义你的功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。<br>3.写Mapper.java，将Mapper.xml中的操作按照id映射成Java函数。<br>4.写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。<br>5.写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。<br>6.写JSP页面调用，请求哪些参数，需要获取什么数据。<br>DataBase ===&gt; Entity ===&gt; Mapper.xml ===&gt; Mapper.Java ===&gt; Service.java ===&gt; Controller.java ===&gt; Jsp.</p><p><a href="https://juejin.im/post/5a715f4ef265da3e5a57935f" target="_blank" rel="noopener">https://juejin.im/post/5a715f4ef265da3e5a57935f</a><br><a href="https://blog.csdn.net/qq_34771403/article/details/63694813" target="_blank" rel="noopener">https://blog.csdn.net/qq_34771403/article/details/63694813</a></p><ul><li>SpringMVC作为view层的实现者，完成用户的请求，其中controller作为整个应用的控制器完成请求及相应。</li><li>Mybatis：作为Dao层的实现者，完成对数据的CRUD</li><li>Spring：以整个应用的大管家，所有的Bean生命周期行为，均由Spring管理，完成对象的创建、初始化、销毁、及对象间关联。<br><img src="https://img-blog.csdnimg.cn/20190417172930302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>工作流程：</p><ol><li>用户通过view页面向服务端，提出请求。（表单请求，Ajax请求，超链接请求等待）</li><li>服务端Controller受到请求后进行解析，找到相应的Model对请求处理</li><li>Model处理完成后，再将结果交给Controller；</li><li>Controller接到处理后，根据结果找到要返回的view页面。页面渲染后</li></ol><p>SpringMVC：<br>1.客户端发送请求到DispacherServlet（分发器）<br>2.由DispacherServlet控制器查询HanderMapping，找到处理请求的Controller<br>3.Controller调用业务逻辑处理后，返回ModelAndView<br>4.DispacherSerclet查询视图解析器，找到ModelAndView指定的视图<br>5.视图负责将结果显示到客户端</p><pre><code>15：struts2和springmvc的区别答：（1）核心控制器不同。Struts2是filter过滤器，而springmvc是servlet。（2）控制器实例不同。Springmvc相比strus2要快一些。（理论上）Struts2是基于对象，所以它是多实例的，而springmvc是基于方法的，所以它是单例的，但是应该避免全局变量的修改，这样会导致线程安全问题。（3）管理方式不同。大部分企业都使用Spring，而Springmvc是spring的一个模块，所以集成更加简单容易，而且提高了全注解的开发形式。而strus2需要采用XML的形式进行配置来进行管理（虽然也可以采用注解，但是公司一般都不会使用）。（4）参数传递不同。Struts2是通过值栈（ValueStack）进行传递和接受，而Springmvc是通过方法的参数来接受，这样Springmvc更加高效。（5）学习程度不同。Struts2存在很多技术点，比如拦截器，值栈，以及OGML表达式，学习成本高，而Springmvc比较简单，上手快。（6）Interrcpter的实现机制不同。Strus2有自己的拦截器的机制，而Springmvc是通过AOP的形式，这样导致strus2的配置文件比springmvc更加庞大。（7）对于Ajax请求不同。Springmvc可以根据注解@responseBody 来对ajax请求执行返回json格式数据，而strus2需要根据插件进行封装返回数据。</code></pre><h3 id="这样设计的好处（Mark）"><a href="#这样设计的好处（Mark）" class="headerlink" title="这样设计的好处（Mark）"></a>这样设计的好处（Mark）</h3><h3 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h3><p>是一个接口。运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。<br>生命周期：init（初始化）；service（）；destroy（）</p><h1 id="2019-4-8-蘑菇街二面："><a href="#2019-4-8-蘑菇街二面：" class="headerlink" title="2019.4.8 蘑菇街二面："></a>2019.4.8 蘑菇街二面：</h1><h3 id="CAS机制除了乐观锁还有什么地方用到，ConcurrentHashMap中CAS怎么用的"><a href="#CAS机制除了乐观锁还有什么地方用到，ConcurrentHashMap中CAS怎么用的" class="headerlink" title="CAS机制除了乐观锁还有什么地方用到，ConcurrentHashMap中CAS怎么用的"></a>CAS机制除了乐观锁还有什么地方用到，ConcurrentHashMap中CAS怎么用的</h3><p>ConcurrentHashMap，1.8，内部大量采用CAS机制以及Synchronized，抛弃了Segment，采用Node，volatile属性实现可见性。锁的粒度也变小了，对每一个Node加锁。<br>CAS举例：在put操作里面，<br>(1)判断key，value是否为null,是的话抛异常。<br>(2)table长度为0的话，重新建表。<br>(3)用CAS机制，判断当前索引的是否为空，空的话直接赋予新的当前值<br>（4）否则的话，如果当前正在扩容表帮助扩容<br>（5）否则的话，此时说明有hash冲突，且不需要帮助扩容操作。我们锁住代码块，进行插入操作，可能会遇到，相等的那就覆盖，没有就插到最后；如果是红黑树另一种操作方法。最后如果插入后大于阈值，再变为树结构。</p><h3 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h3><ul><li><p>进程：资源分配的基本单位；线程：独立调度的基本单位</p><ol><li>拥有资源：进程是资源分配单位，线程可以访问隶属进程</li><li>调度：同一进程，线程切换不会导致进程切换，不同进程的线程切换会导致进程切换，资料消耗大。</li><li>系统开销：进程创建销毁，系统为之分配回收资源，线程切换只需保存，设置寄存器内容。</li></ol></li><li><p>进程通信：<br>管道：适用于具有亲缘关系的父子进程，命名管道也允许没有亲缘关系的<br>信号：<br>消息队列：<br>共享内存：多个进程访问同一快内存，不同进程可以及时看到对方进程中对数据的更新。<br>信号量：进程间，以及同一进程不同线程的同步手段<br>套接字：socket</p><ul><li>线程通信：<br>互斥量：synchronized，lock<br>信号量：semphare：允许同一时刻多个线程访问同一资源<br>事件：wait/notify</li></ul></li></ul><h3 id="死锁详细了解"><a href="#死锁详细了解" class="headerlink" title="死锁详细了解"></a>死锁详细了解</h3><ul><li><p>死锁：指的两个或多个并发的进程，如果两个进程持有某种资源而又等待着其他进程释放他或他们现在保持着的资源，在未改变这种状态之前都不能向前前进。无限期的阻塞、相互等待的状态。</p></li><li><p>产生的四个必要条件，有一个条件得不到满足就不可能发生死锁：</p></li></ul><ol><li>互斥：至少一个资源是非共享模式，一次只允许一个进程访问</li><li>占有并等待：一个进程本身就占有一个资源，同时还需要其他资源，等待其他进程释放这个资源。</li><li>非抢占：别人已经有了某个资源，不能因为需要就去抢夺别人的资源</li><li>循环等待：存在一个进程链，每个进程都占有下一个进程所需的至少一种资源。</li></ol><h4 id="死锁的解决策略"><a href="#死锁的解决策略" class="headerlink" title="死锁的解决策略"></a>死锁的解决策略</h4><ul><li>忽略该问题（鸵鸟算法）</li><li>检测死锁并恢复<br>检测方法：</li></ul><p>1.每个类型一个资源：深度优先搜索<br>2.每个类型多个资源：矩阵C+A=E<br>恢复方法：<br>1.利用抢占恢复<br>2.回滚恢复<br>3.杀死进程恢复</p><ul><li>破坏四个条件之一，<strong><em>预防死锁</em></strong>：</li></ul><ol><li><p>破坏占有且等待：所有进程运行前，必须申请整个过程中所有的资源，申请到了才可以运行；允许只获得初期需要的资源，便开始运行，过程中逐渐释放使用完成的资源，然后再去请求。</p></li><li><p>破坏不可抢占：当一个进程持有了一些资源，请求新资源无法满足，他必须释放已经保持的所有资源。这种方法实现困难，代价很大。</p></li><li><p>破坏循环等待：对资源进行编号，当一个进程占有编号i的资源，下一次只能占有比她大的资源。</p></li></ol><ul><li>仔细对资源动态分配，从而<strong>避免死锁</strong>（比死锁预防的限制要少）<strong>银行家算法</strong>：</li></ul><ol><li><p>有序资源分配法（通过破坏环路条件来实现）：将所有资源编号，申请时必须上升的次序。</p></li><li><p>银行家算法：可利用资源向量Available、最大需求矩阵Max、分配矩阵(当前已分配)Allocation、需求矩阵Need=Max-Allocation。request代表进程的一次请求资源量。Finish表示某个进程的状态</p><p><strong>安全状态检测算法</strong>：（1）不断扫面所有进程，如果finish=false，need&lt;Allocation，满足第2否则第3 （2）满足说明该进程可以完成，假设已经完成，银行收回了给进程的资源。Available+=Allocation，并且另Finish=true。（3）如果此时所有都是true说明安全，否则就是不安全的</p><p><strong>资源请求算法</strong>：（1）如果需求request&gt;Need，拒绝（2）如果request&gt;Available，拒绝；（3）以上都不满足分配资源：Available-=request；Need-=request；Allocation+=request。<br>然后用安全状态检测算法，检测这次请求后系统是否安全，安全就生效，不安全就推迟。</p><ul><li>死锁检测：就是相当于安全状态检测算法</li><li>死锁解除：撤销或者挂起一些进程，以便回收一些资源，再将资源分配给处于阻塞状态的线程。进程回退发、</li></ul></li></ol><ul><li>Java中的死锁检测：<br>Jconsole： （JAVA_HOME/bin目录下）可以连接本地或远程的JVM，查看内存、线程、类、JVM概要。在线程菜单可以检测死锁，查看死锁原因。<br>Jstack：JDK自带的命令行工具，用于线程Dump分析(Dump文件是进程的内存镜像。保存的是进程的执行状态信息)<br>1、jps查看进程信息<br>2、找到要调试的进程号，jstack -l pid  可以得到死锁位置<h3 id="vector-和-arraylist"><a href="#vector-和-arraylist" class="headerlink" title="vector 和 arraylist"></a>vector 和 arraylist</h3></li><li>vector对集合元素操作都加了Synchronize实现同步</li><li>扩容不一样，vector扩容增大一倍，arraylist默认增大0.5倍，同时可以修改的增大多少有一个参数，arraylist不可以设置增量大小</li></ul><h3 id="volatile-到底实现了哪些特性："><a href="#volatile-到底实现了哪些特性：" class="headerlink" title="volatile 到底实现了哪些特性："></a>volatile 到底实现了哪些特性：</h3><p>无法保证原子性，可在一定程度保证有序，实现了可见性。</p><h3 id="物理内存、虚拟内存区别："><a href="#物理内存、虚拟内存区别：" class="headerlink" title="物理内存、虚拟内存区别："></a>物理内存、虚拟内存区别：</h3><p>物理内存就是实际的内存，在cpu中指的是实际的寻址空间大小，32位就是4G<br>虚拟内存：进程运行时</p><h1 id="4-10-阿里一面："><a href="#4-10-阿里一面：" class="headerlink" title="4.10 阿里一面："></a>4.10 阿里一面：</h1><h3 id="Spring-底层实现，怎么去做的，怎么去实现的。"><a href="#Spring-底层实现，怎么去做的，怎么去实现的。" class="headerlink" title="Spring 底层实现，怎么去做的，怎么去实现的。"></a>Spring 底层实现，怎么去做的，怎么去实现的。</h3><h3 id="如何学习多线程知识"><a href="#如何学习多线程知识" class="headerlink" title="如何学习多线程知识"></a>如何学习多线程知识</h3><h3 id="要系统的学习Java知识"><a href="#要系统的学习Java知识" class="headerlink" title="要系统的学习Java知识"></a>要系统的学习Java知识</h3><h3 id="基础系统的学习"><a href="#基础系统的学习" class="headerlink" title="基础系统的学习"></a>基础系统的学习</h3><h1 id="4-11作业帮一面"><a href="#4-11作业帮一面" class="headerlink" title="4.11作业帮一面"></a>4.11作业帮一面</h1><h3 id="哈希一致性，高并发，redis应用场景"><a href="#哈希一致性，高并发，redis应用场景" class="headerlink" title="哈希一致性，高并发，redis应用场景"></a>哈希一致性，高并发，redis应用场景</h3><p><img src="https://img-blog.csdnimg.cn/20190420155300140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>redis有序集合实现聊天记录： app缓存清除了之后，没法再看到聊天记录，说明他不会去数据库查找聊天记录，只是查找手机上的缓存。</li><li>哈希结构：商品有好几个可以编辑，每个人是一个小key。</li></ul><h1 id="4-12招银网络一面"><a href="#4-12招银网络一面" class="headerlink" title="4.12招银网络一面"></a>4.12招银网络一面</h1><h3 id="tomcat服务器怎么跟小程序通信"><a href="#tomcat服务器怎么跟小程序通信" class="headerlink" title="tomcat服务器怎么跟小程序通信"></a>tomcat服务器怎么跟小程序通信</h3><h3 id="小程序ajax访问的权限"><a href="#小程序ajax访问的权限" class="headerlink" title="小程序ajax访问的权限"></a>小程序ajax访问的权限</h3><p>小程序特点，数据发生变化，前端页面也会直接发生变化</p><h3 id="小程序访问限制，黑客进入"><a href="#小程序访问限制，黑客进入" class="headerlink" title="小程序访问限制，黑客进入"></a>小程序访问限制，黑客进入</h3><h3 id="两个人同时改到相同代码，如何解决"><a href="#两个人同时改到相同代码，如何解决" class="headerlink" title="两个人同时改到相同代码，如何解决"></a>两个人同时改到相同代码，如何解决</h3><h3 id="数据库的设计有什么感触，范式"><a href="#数据库的设计有什么感触，范式" class="headerlink" title="数据库的设计有什么感触，范式"></a>数据库的设计有什么感触，范式</h3><h3 id="博客里面有图片，文字，如何存储"><a href="#博客里面有图片，文字，如何存储" class="headerlink" title="博客里面有图片，文字，如何存储"></a>博客里面有图片，文字，如何存储</h3><p>长段文字（TEXT  LONGTEXT）</p><ul><li>Mysql数据类型：<br>数值类型:<br><img src="https://img-blog.csdnimg.cn/20190419171335384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>日期和时间类型：<br><img src="https://img-blog.csdnimg.cn/20190419171544656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>字符串类型：<br><img src="https://img-blog.csdnimg.cn/20190419171741712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="4-13作业帮二面"><a href="#4-13作业帮二面" class="headerlink" title="4.13作业帮二面"></a>4.13作业帮二面</h1><h3 id="数据分页问题"><a href="#数据分页问题" class="headerlink" title="数据分页问题"></a>数据分页问题</h3><pre><code>Limit 5; 从第一个数0开始，到4的5个数Limit 5，5；从5开始的5个数     代替为  Limit 4 offset 3 从行3开始的4行若果要求返回的行数大于剩下的行数，就返回剩下的行数 Limit优化方案</code></pre><ul><li><p>后端解决方案：前端传数据包括（当前页数page，以及每页的个数pagesize），后端(page-1)<em>pagesize到page</em>pagesize的数据，同时判断总共数据个数，考虑最后一页的情况。</p><p>  offset(代表需要跳过的个数) = (page-1)*pagesize<br>  skip(offset).limit(pagesize)</p></li></ul><p>具体也有三种方法：<br>（1）通过数组进行分页，第一次把所有的数据都取过来，然后每次对数组取索引范围内的值。<br>（2） sql语句里面实现：select * from student limit #{page}，#{pagesize}</p><h4 id="问题与优化："><a href="#问题与优化：" class="headerlink" title="问题与优化："></a><a href="https://aotu.io/notes/2017/06/27/infinite-scrolling/index.html" target="_blank" rel="noopener">问题与优化</a>：</h4><ol><li><p>数据缺失：第一次取了20-11数据；期间有人删除了第17条数据，此时再去取第二页会导致第10个数据缺失，只会取1-9的数据。</p></li><li><p>数据重复：第一次取20-11，此时又增加了一条数据，变为21条，第二次取就会重复取到第11条数据。</p></li></ol><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><ul><li><p>时间分片式缓存<br>使用缓存，（按时间分片式缓存）。<br>前端传的数据增加时间戳（timestamp），请求第一页数据时，timestamp =0 。接下来每次将第一步返回的timestamp输出。<br>后端：对于timestamp为0的话，生成当前时间对应的缓存，并返回前端所需；若timestamp不为0，且缓存不存在，则提示“刷新数据”。若存在，则直接返回。</p></li><li><p>游标式分页<br>客户端记录，分页的最后一个数据ID，请求下一页时候告诉上次请求的ID。<br>优点：避免重复遗漏，不需要计算offset<br>缺点：只适合按照时间追加的方式简单排序。</p></li><li><p>一次性下发ID（适用于id列表不会很大的业务场景）<br>第一次请求把所有的ID以及第一页的数据给前端<br>之后再请求，前端只需要自己去加id，告诉后台需要那些数据</p><ul><li>客户端排除<br>客户端中保存已经加载的id，每次请求玩先去重</li></ul></li></ul><h4 id="无限下拉的方法（用户下滑时更新页面）"><a href="#无限下拉的方法（用户下滑时更新页面）" class="headerlink" title="无限下拉的方法（用户下滑时更新页面）"></a>无限下拉的方法（用户下滑时更新页面）</h4><h1 id="4-17-小米一面"><a href="#4-17-小米一面" class="headerlink" title="4.17 小米一面"></a>4.17 小米一面</h1><h3 id="问道了分页时候，如果有别人操作数据库，导致数据重复或消失"><a href="#问道了分页时候，如果有别人操作数据库，导致数据重复或消失" class="headerlink" title="问道了分页时候，如果有别人操作数据库，导致数据重复或消失"></a>问道了分页时候，如果有别人操作数据库，导致数据重复或消失</h3><p>答案见上面</p><h3 id="sql问题：1-查找表得到年龄大于20的男性、女性数量-2-group-by，查班级年龄，及每个数量的个数，年龄大于5"><a href="#sql问题：1-查找表得到年龄大于20的男性、女性数量-2-group-by，查班级年龄，及每个数量的个数，年龄大于5" class="headerlink" title="sql问题：1.查找表得到年龄大于20的男性、女性数量 2. group by，查班级年龄，及每个数量的个数，年龄大于5"></a>sql问题：1.查找表得到年龄大于20的男性、女性数量 2. group by，查班级年龄，及每个数量的个数，年龄大于5</h3><h3 id="stringBuffer-、-Stringbuilder-、string-区别"><a href="#stringBuffer-、-Stringbuilder-、string-区别" class="headerlink" title="stringBuffer 、 Stringbuilder 、string 区别"></a>stringBuffer 、 Stringbuilder 、string 区别</h3><h3 id="分布式锁，redis-如何实现"><a href="#分布式锁，redis-如何实现" class="headerlink" title="分布式锁，redis 如何实现"></a>分布式锁，redis 如何实现</h3><h3 id="SprngBoot了解吗"><a href="#SprngBoot了解吗" class="headerlink" title="SprngBoot了解吗"></a>SprngBoot了解吗</h3><h3 id="大数相加和大数相减，大数相乘"><a href="#大数相加和大数相减，大数相乘" class="headerlink" title="大数相加和大数相减，大数相乘"></a>大数相加和大数相减，大数相乘</h3><p>  大数相乘思路：第i位*第j位 等于 新的数组的第i+j位的数，先对两个数进行遍历，</p><pre><code>for (int i = 0; i &lt; a.length; i++) {            for (int j = 0; j &lt; b.length; j++) {                result[i + j] += (int) (a[i] - &#39;0&#39;) * (int) (b[j] - &#39;0&#39;);            }        }</code></pre><p>最后对res的每一位判断，大于10的话，要进位。进位的要进给前边的。</p><h1 id="4-17-阿里二面"><a href="#4-17-阿里二面" class="headerlink" title="4.17 阿里二面"></a>4.17 阿里二面</h1><h3 id="小程序登陆接口设置（Session），如何加密（MD5）"><a href="#小程序登陆接口设置（Session），如何加密（MD5）" class="headerlink" title="小程序登陆接口设置（Session），如何加密（MD5）"></a>小程序登陆接口设置（Session），如何加密（MD5）</h3><ul><li><p>MD5加密算法</p><p>  对称加密算法：DES算法，3DES算法，TDEA算法，Blowfish算法，RC5算法，IDEA算法，AES算法。<br>  非对称加密算法：RSA、Elgamal、背包算法、Rabin、D-H、ECC。<br>  经典的哈希算法：MD2、MD4、MD5 和 SHA-1（目的是将任意长输入通过算法变为固定长输出，且保证输入变化一点输出都不同，且不能反向解密）</p></li></ul><p>MD5不可逆，生成信息摘要后，不能通过解析获得原来的内容</p><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><ul><li>内部通过 volatile数组+ReentrantLock锁 实现</li><li>读写分离的同步机制，读不加锁，写先复制到另一个数组，再复制数组中添加，然后复制数组替代原数组</li><li>应用场景：读多写少，（商品类目、黑名单）通过</li></ul><h3 id="hashtable-和-ConcurrentHahsMap"><a href="#hashtable-和-ConcurrentHahsMap" class="headerlink" title="hashtable 和 ConcurrentHahsMap"></a><a href="http://antsnote.club/2018/05/31/Java-ConcurrentHashMap/" target="_blank" rel="noopener">hashtable 和 ConcurrentHahsMap</a></h3><p>currentHashmap：<br>1.volatile 对Node类的属性，保证可见性<br>2.如果没有hash冲突那么通过CAS机制去添加，如果有的话，再去通过synchronized 更小粒度的锁代码块</p><p>size操作</p><h1 id="4-24-OPPO（看看海量数据面试题）"><a href="#4-24-OPPO（看看海量数据面试题）" class="headerlink" title="4.24 OPPO（看看海量数据面试题）"></a>4.24 OPPO（看看<a href="https://blog.csdn.net/v_july_v/article/details/7382693" target="_blank" rel="noopener">海量数据面试题</a>）</h1><h3 id="海量数据查找"><a href="#海量数据查找" class="headerlink" title="海量数据查找"></a>海量数据查找</h3><ul><li>布隆过滤器（hash set）</li></ul><p>m位的位数组，k个哈希函数，把temp求k个哈希，同时将结果中的位置值为1<br>缺点：误算率；不可删除，删除的也许另一个值也是1</p><ul><li>倒排索引查找</li></ul><h3 id="海量数据TOPk"><a href="#海量数据TOPk" class="headerlink" title="海量数据TOPk"></a>海量数据TOPk</h3><p>分治+Trie树/hash+小顶堆：<br>先按哈希方法分成多个小数据集</p><p>建立最小堆，如果大于最小的，就替代最小的，同时保持最小堆</p><h3 id="位图法（适用于数据比较密集的-："><a href="#位图法（适用于数据比较密集的-：" class="headerlink" title="位图法（适用于数据比较密集的)："></a>位图法（适用于数据比较密集的)：</h3><ul><li>方法：通过一个数组int bit[N]，可以存储N * 32个数据，最大的数N * 32-1；数组大小是最大值-最小值<br>把每个数据存在一个位上面，方法是数temp，存储在bit[temp/32] 其中第temp%32位设为1。</li></ul><pre><code>#define BITSPERWORD 32 #define SHIFT 5 #define MASK 0x1F #define N 10000000 void set(int i) { //将指定的bit赋1    a[i&gt;&gt;SHIFT] |= (1&lt;&lt;(i &amp; MASK)); } //将i右移动，就是除32，然后求32的余数void clr(int i) { //将指定的bit清0    a[i&gt;&gt;SHIFT] &amp;= ~(1&lt;&lt;(i &amp; MASK)); } int test(int i){//取一下存入的值  每5 bit是一组。    return a[i&gt;&gt;SHIFT] &amp; (1&lt;&lt;(i &amp; MASK)); } </code></pre><ul><li><p>应用：</p><p>  海量数据排序：大量数据1000,000,000中的900,000,000个不重复的正整数排序，<br>  1000000000/(8* 1024*1024)=119.2MB空间<br>  先找到最大值，最小值。然后位图法的范围就是最大值减最小值。对于每个数的存储就是该数减去最小值。</p></li></ul><pre><code>海量数据去重：在2.5亿个整数中找出不重复的整数，00表示没有出现，01表示出现一次，10表示出现多次，232∗2=1 GB(这里没有限定整数的范围，所有把所有32位整数都考虑进去)</code></pre><p>应用1：某文件中包含一些8位的电话号码，统计出现的号码的个数？（判断有谁出现）<br>8为最大是99 999 999，大约是99M的bit，12.5MB的内存，就可以统计出来出现的号码。</p><p>应用2：某文件中包含一些8位的电话号码，统计只出现一次的号码？（判断有谁出现并且指出现1次）<br>  需要扩展一下，可以用两个bit表示一个号码，0代表没有出现过，1代表只出现过1次，2代表至少出现2次。 </p><p>应用3：有两个文件，文件1中有1亿个10位的qq号码，文件2中有5千万个10位qq号码，判断两个文件中重复出现的qq号。<br>首先建立10的10次方个大小的位数组（占用内存大约是1.25G），全部初始化为0，读取第一个文件，对应的qq号存放到对应的未知，数值改为1，如果重复出现仍是1.读取完毕第一个文件后，读取第二个文件，对应的位置为1则表示重复出现。</p><p> 应用4：有两个文件，文件1中有1亿个15位的qq号码，文件2中有5千万个15位的qq号码，判断两个文件中重复出现的qq号。<br>应用4中，qq号码上升为15位的时候，显然内存是不够用了，这个时候怎么办？使用<strong>Bloom Filter（布隆过滤器）</strong></p><p>可读性差<br>位图存储的元素个数虽然比一般做法多，但是存储的元素大小受限于存储空间的大小。位图存储性质：存储的元素个数等于元素的最大值。比如， 1K 字节内存，能存储 8K 个值大小上限为 8K 的元素。（元素值上限为 8K ，这个局限性很大！）比如，要存储值为 65535 的数，就必须要 65535/8=8K 字节的内存。要就导致了位图法根本不适合存 unsigned int 类型的数（大约需要 2^32/8=5 亿字节的内存）。<br>位图对有符号类型数据的存储，需要 2 位来表示一个有符号元素。这会让位图能存储的元素个数，元素值大小上限减半。 比如 8K 字节内存空间存储 short 类型数据只能存 8K*4=32K 个，元素值大小范围为 -32K~32K 。</p><h3 id="Trie树（字典树）"><a href="#Trie树（字典树）" class="headerlink" title="Trie树（字典树）"></a>Trie树（字典树）</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer(上)</title>
      <link href="/2019/03/11/%E5%89%91%E6%8C%87offer%20NO.1%EF%BC%882018.12.25%E2%80%94%E2%80%942018.1.25%EF%BC%89/"/>
      <url>/2019/03/11/%E5%89%91%E6%8C%87offer%20NO.1%EF%BC%882018.12.25%E2%80%94%E2%80%942018.1.25%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">     public static void main(String[] args) {            Scanner in = new Scanner(System.in);            while (in.hasNextInt()) {//注意while处理多个case                int a = in.nextInt();                int b = in.nextInt();                System.out.println(a + b);            }        }</code></pre><h3 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h3><ul><li><p>题意：二维数组从左至右递增，从上至下递增，给一个数判断是否在里面</p></li><li><p>思路：找到数组的规律，从左下角开始找最好，如果目标比他大，向右移动；如果比他小，向左移动。</p></li></ul><pre><code class="java">public class Solution {    public boolean Find(int target, int [][] array) {        int a = array.length;        int b = array[0].length;         for(int i = a-1,j= 0;i&gt;=0&amp;&amp;j&lt;b;){            if(array[i][j]&gt;target ){                i--;            }            else if(array[i][j]&lt;target){                j++;            }            else{                return true;            }                     }        return false;    }}</code></pre><h3 id="2-替换空格："><a href="#2-替换空格：" class="headerlink" title="2. 替换空格："></a>2. 替换空格：</h3><ul><li>题目：将一个字符串的所有空格转变成“20%”</li><li>思路：stringbuffer     先计算有几个空格，然后从后往前进行改变，这样就只需要一次了。</li></ul><pre><code class="java">public static String replaceSpace(StringBuffer str) {        int l = str.length();        int space = 0;        for(int i = 0;i&lt;l;i++) {            if(str.charAt(i)==&#39; &#39;) {                space++;            }        }        space = 2*space;        str.setLength(l+space);               for(int i = l-1,j = l-1+space;i&gt;=0;) {                        if(str.charAt(i)!=&#39; &#39;) {                str.setCharAt(j, str.charAt(i));                i--;                j--;            }            else {                str.setCharAt(j,&#39;0&#39;);                  j--;                str.setCharAt(j,&#39;2&#39;);                    j--;                str.setCharAt(j,&#39;%&#39;);                j--;                i--;                            }        }        String res = str.toString();                    return res;    }</code></pre><h3 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3. 从尾到头打印链表"></a>3. 从尾到头打印链表</h3><ul><li><p>输入一个链表，从尾到头输出</p></li><li><p>思路1：将数据放入堆栈，，最后pop出来，即可实现</p><pre><code class="java">import java.util.Stack;import java.util.ArrayList;public class Solution {  public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {     ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();      Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;();      while(listNode != null) {          s.push(listNode.val);          listNode = listNode.next;      }      while(!s.isEmpty()) {          res.add(s.pop());      }      return res;  }}</code></pre></li><li><p>思路2：递归的方法（第二遍再写）MARK</p></li></ul><h3 id="4-用两个栈实现队列"><a href="#4-用两个栈实现队列" class="headerlink" title="4. 用两个栈实现队列"></a>4. 用两个栈实现队列</h3><ul><li>题意：队列先进先出，栈先进后出</li><li>思路：进入的时候向A栈放，出去的时候A放到B里面，从B出栈</li></ul><pre><code class="java">public class Solution {    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();    public void push(int node) {        stack1.push(node);    }    public int pop() {        if(stack2.isEmpty()){            while(!stack1.isEmpty()){                stack2.push(stack1.pop());            }        }        return stack2.pop();    }}</code></pre><h3 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h3><ul><li><p>思路:  理解  非减排序 == 递增排序；     得到一个递增排序旋转，然后去找最小值，二分法。</p></li><li><p>如果没有重复值的话：mid值大于等于start，则最小值在第二部分；否则最小值在第一部分。最后end就为最小值</p></li><li><p>如果有重复值的话，如101111111，111111101<br>此时需要判断min等于第一个值和最后一个值——只能顺序查找</p><pre><code class="java">  public static int minNumberInRotateArray(int [] array) {      int len = array.length;      if (len == 0) {          return 0;      }      else {                        int[] res = new int[2];          res = binary(0,len-1,array);          while(res[1] - res[0] !=1 &amp;&amp; res[0] != -1){                            res = binary(res[0],res[1],array);               }          if(res[0] == -1){              int min = array[0];              for(int i = 0;i&lt;len;i++) {                  if(min&gt;array[i]) {                      min = array[i];                  }              }              return min;          }          else{              return array[res[1]]&lt;array[res[0]]?array[res[1]]:array[res[1]];          }          }      }      public static int[] binary(int start, int end,int [] a){              int[] res1 = new int[2];           int mid = (start+end)/2;          if(a[mid] == a[start] &amp;&amp; a[mid] == a[end]) {              res1[0] = -1;              res1[1] = -1;              return res1;                          }else if(a[mid]&gt;=a[start]){              res1[0] = mid;              res1[1] = end;                      return res1;          }          else{                  res1[0] = start;              res1[1] = mid;                      return res1;          }      }</code></pre></li></ul><h3 id="6-斐波那契数列"><a href="#6-斐波那契数列" class="headerlink" title="6. 斐波那契数列"></a>6. 斐波那契数列</h3><ul><li>思路：就很简单。。。。；补充给一个值找到他是第几项</li></ul><pre><code class="java">public static int Fibonacci(int n) {        int a = 0,b = 1,c;        if(n == 0) {            return 0;        }else {            for(int i =0;i&lt;n-1;i++) {                c = a+b;                a = b;                b = c;            }            return b;        }</code></pre><h3 id="6-斐波那契变形！！"><a href="#6-斐波那契变形！！" class="headerlink" title="6. 斐波那契变形！！"></a>6. 斐波那契变形！！</h3><blockquote><p>Fibonacci数列是这样定义的： F[0] = 0 F[1] = 1 for each i ≥ 2: F[i] = F[i-1] +<br>F[i-2] 因此，Fibonacci数列就形如：0, 1, 1, 2, 3, 5, 8, 13,<br>…，在Fibonacci数列中的数我们称为Fibonacci数。给你一个N，你想让其变为一个Fibonacci数，每一步你可以把当前数字X变为X-1或者X+1，现在给你一个数N求最少需要多少步可以变为Fibonacci数。</p></blockquote><blockquote><p>输入描述: 输入为一个正整数N(1 ≤ N ≤ 1,000,000)</p></blockquote><blockquote><p>输出描述: 输出一个最小的步数变为Fibonacci数”</p></blockquote><pre><code class="java">import java.util.Scanner;public class Main{    public static void main(String[] args) {    Scanner i = new Scanner(System.in);    System.out.println(FibI(i.nextInt()));}    public static int FibI(int n) {        int a = 0,b = 1,c;        while(true) {            if(n&gt;=a &amp;&amp; n&lt;=b) {                break;            }                    c = a+b;            a = b;            b = c;        }        return n-a&gt;b-n?b-n:n-a;    }}</code></pre><h3 id="6-跳台阶"><a href="#6-跳台阶" class="headerlink" title="6. 跳台阶"></a>6. 跳台阶</h3><blockquote><p>题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><ul><li>思路：通过列举发现，n = 1，一种；n = 2，两种。只有1步和2步，则跳到n的话，只可能n-1位置跳1步过去；n-2位置跳2步过去</li></ul><pre><code class="java">    public static int JumpFloor(int target) {        if(target&lt;=2) {            return target;        }        return JumpFloor(target-2) +JumpFloor(target-1);</code></pre><h3 id="6-变态跳台阶："><a href="#6-变态跳台阶：" class="headerlink" title="6. 变态跳台阶："></a>6. 变态跳台阶：</h3><blockquote><p>题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><ul><li>思路此时n的大小等于，f(n-1)+……f(1)+1，基础部分就是f(1)= 1，递归即可—</li></ul><pre><code class="java">public static int JumpFloorII(int target) {        if(target&lt;=2) {            return target;        }        int res = 0;        while(target&gt;1) {            res += JumpFloorII(target-1);            target --;        }        return res+1;    }</code></pre><h3 id="7-矩形覆盖"><a href="#7-矩形覆盖" class="headerlink" title="7. 矩形覆盖"></a>7. 矩形覆盖</h3><blockquote><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p></blockquote><pre><code class="java">public class Solution {    public int RectCover(int target) {        if(target&lt;=2){            return target;        }        return RectCover(target-1)+RectCover(target-2);    }}</code></pre><h3 id="8-二进制中1的个数"><a href="#8-二进制中1的个数" class="headerlink" title="8. 二进制中1的个数"></a>8. 二进制中1的个数</h3><blockquote><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p></blockquote><ul><li>思路：计算机里面二进制存储各个数字，负数用补码；所以就是通过位运算，得到数字中的1的个数。int32位，通过一个数（0x 80000000）来循环右移得到二进制表示。</li></ul><pre><code class="java">public int NumberOf1(int n) {        int count = 0;        for (int i = 0; i &lt; 32; i++)        {            int t = (n &amp; 0x80000000 &gt;&gt;&gt; i) &gt;&gt;&gt; (31 - i);            if(t == 1){                count++;            }        }        return count;    }</code></pre><ul><li>巧妙方法</li></ul><pre><code class="java">public int NumberOf1(int n) {        int count = 0;        while(n!= 0){            count++;            n = n &amp; (n - 1);         }        return count;    }</code></pre><blockquote><p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p></blockquote><h3 id="9-数值的整数次方"><a href="#9-数值的整数次方" class="headerlink" title="9. 数值的整数次方"></a>9. 数值的整数次方</h3><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p></blockquote><ul><li><pre><code class="java">public double Power(double base, int exponent) {      double res=1.0;      if(exponent&gt;=0){          for(int i=0;i&lt;exponent;i++){          res =res*base;      }                 }      else{          base = 1.0/base;          for(int i=0;i&lt;-exponent;i++){              res =res*base;          }      }      return res;}</code></pre><h3 id="10-调整数组顺序使奇数位于偶数前面"><a href="#10-调整数组顺序使奇数位于偶数前面" class="headerlink" title="10. 调整数组顺序使奇数位于偶数前面"></a>10. 调整数组顺序使奇数位于偶数前面</h3></li></ul><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p></blockquote><ul><li>思路1：空间复杂度O(n)，空间换时间</li></ul><pre><code class="java">public static void reOrderArray(int [] array) {        int len = array.length,j=0;        int[] res = new int[len];        res = array.clone();            for(int i=0;i&lt;len;i++) {            if(res[i]%2!=0) {                array[j] = res[i];                j++;            }                }        for(int i=0;i&lt;len;i++) {            if(res[i]%2==0) {                array[j] = res[i];                j++;            }        }    }</code></pre><ul><li>思路2：O(n2)， 从后往前，n次遍历。每次判断相邻的，前奇数后偶数；这样可以实现奇数都在最前面，并且是按顺序的。</li></ul><pre><code class="java"> for (int i = 0; i &lt; array.size();i++)        {            for (int j = array.size() - 1; j&gt;i;j--)            {                if (array[j] % 2 == 1 &amp;&amp; array[j - 1]%2 == 0) //前偶后奇交换                {                    swap(array[j], array[j-1]);                }            }        }    }</code></pre><h3 id="11-链表倒数第k个结点"><a href="#11-链表倒数第k个结点" class="headerlink" title="11. 链表倒数第k个结点"></a>11. 链表倒数第k个结点</h3><blockquote><p>题目描述 输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><ul><li><p>思路1：遍历两次，一次计算总共长度，第二次再遍历到倒数第k个结点</p><pre><code class="java">public ListNode FindKthToTail(ListNode head,int k) {      ListNode r = head;      int l = 1;      if(head == null | k&lt;0){          return null;      }      while(r.next != null){          r = r.next;          l++;      }      if(l&lt;k)          return null;      for(int i =0;i&lt;=l-k-1;i++){          head = head.next;      }      return head;  }</code></pre></li><li><p>思路2：遍历一遍，用两个指针即可</p></li></ul><pre><code class="java">public ListNode FindKthToTail(ListNode head,int k) {        ListNode a = head;        ListNode b = head;        if(head == null|k&lt;0){            return null;        }        int i = 0;        while(a!=null &amp; i&lt;k){            i++;            a = a.next;        }        if(i!=k){            return null;        }        while(a!=null){            b = b.next;            a = a.next;        }        return b;    }</code></pre><h3 id="12-反转链表"><a href="#12-反转链表" class="headerlink" title="12. 反转链表"></a>12. 反转链表</h3><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p><ul><li>思路1：很笨的方法，将链表反转，头结点就是最后一个，先得到最后一个结点，然后再倒着将所有的结点val值加入。O(n2)<pre><code class="java">public ListNode ReverseList(ListNode head) {      if(head == null||head.next == null){          return head;      }      ListNode a = head;      int l = 1;      while(a.next!= null){          a = a.next;          l++;      }      ListNode res = a;      for(int i=l-2;i&gt;=0;i--){          ListNode b = head;          for(int j=0;j&lt;i;j++){              b = b.next;          }          ListNode C = new ListNode(b.val);          a.next = C;          a = a.next;      }      return res;  }</code></pre></li><li>思路2：简单方法！！！只进行一遍遍历，记录当前结点的前一个、后一个。<br>先记录当前结点的后一个，然后将结点的后一个赋值为前一个；<br>再将当前结点变为后一个，前一个结点变为当前结点</li></ul></blockquote><pre><code class="java">public ListNode ReverseList(ListNode head) {        ListNode pre = null;        ListNode behind ;        if(head == null||head.next == null){            return head;        }        while(head!=null){            behind = head.next;            head.next = pre;            pre = head;            head = behind;        }        return pre;    }</code></pre><h3 id="13-合并两个排序的链表"><a href="#13-合并两个排序的链表" class="headerlink" title="13. 合并两个排序的链表"></a>13. 合并两个排序的链表</h3><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><ul><li>思路1：简单法（非递归法），两个链表进行一次遍历，小的值先放进新链表中，直到两个链表值都取了</li></ul><pre><code class="java">public static ListNode Merge(ListNode list1,ListNode list2) {        ListNode res = new ListNode(0);        ListNode a = new ListNode(0);        a.next = res;        while(list1 !=null || list2 !=null){            if(list1 ==null &amp;&amp; list2 !=null){                res.next = list2;                list2 = null;            }else if(list1 !=null &amp;&amp; list2 ==null){                res.next = list1;                list1 = null;            }else{                if(list1.val&lt;list2.val){                    ListNode C = new ListNode(list1.val);                    res.next = C;                    res = res.next;                    list1 = list1.next;                }else{                    ListNode C = new ListNode(list2.val);                    res.next = C;                    res = res.next;                    list2 = list2.next;                }            }        }        return res.next.next;    }</code></pre><ul><li>思路2：递归法，重复调用！！！！！！！！！！！！！</li></ul><pre><code class="java">public ListNode Merge(ListNode list1,ListNode list2) {        if(list1 ==null ){            return list2;        }        if(list2 ==null){            return list1;        }            if(list1.val&lt;list2.val){                list1.next = Merge(list1.next,list2);                return list1;            }else{                list2.next = Merge(list1,list2.next);                return list2;                }    }</code></pre><h3 id="14-顺时针打印矩阵"><a href="#14-顺时针打印矩阵" class="headerlink" title="14.顺时针打印矩阵"></a>14.顺时针打印矩阵</h3><ul><li>思路1：ZZ做法，复杂极其</li></ul><pre><code class="java">public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) {        int a = matrix.length;        int b = matrix[0].length;        ArrayList res = new ArrayList();        int start = 0,end = a-1;        int flag = 0;        if(a == 1){            for(int j=0;j&lt;b;j++){                res.add(matrix[0][j]);            }            return res;        }        if(b == 1){            for(int i=0;i&lt;a;i++){                res.add(matrix[i][0]);            }            return res;        }        while(start!=end){            if(end-start==1){                for(int j =flag;j&lt;=b-1-flag;j++){                    res.add(matrix[start][j]);                }                for(int j =b-1-flag;j&gt;=flag;j--){                    res.add(matrix[end][j]);                }                return res;            }            for(int j =flag;j&lt;=b-1-flag;j++){                res.add(matrix[start][j]);            }            for(int i=start+1;i&lt;end;i++){                res.add(matrix[i][b-1-flag]);            }            for(int j =b-1-flag;j&gt;=flag;j--){                res.add(matrix[end][j]);            }            for(int i=end-1;i&gt;start;i--){                res.add(matrix[i][flag]);            }            if(end-start==2){                for(int j=flag+1;j&lt;b-1-flag;j++){                    res.add(matrix[end-1][j]);                }                return res;            }            if(b-1-flag ==flag+1){                return res;            }            if(b-1-flag ==flag+2){                for(int i =start+1;i&lt;=end-1;i++){                    res.add(matrix[i][flag+1]);                }                return res;            }            start++;            end--;            flag++;        }        return res;    }</code></pre><h3 id="15-包含min函数的栈："><a href="#15-包含min函数的栈：" class="headerlink" title="15.包含min函数的栈："></a>15.包含min函数的栈：</h3><blockquote><p>题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p></blockquote><p>-思路：任务完成栈的数据结构同时要加一个min函数，完成出栈、入栈、获取栈顶元素。<br>规定了时间复杂度，肯定要牺牲空间。加入min辅助栈，出栈的时候两个都出；入栈的时候，min栈需要比较大小；最小值总是在min的top</p><pre><code class="java">static Stack&lt;Integer&gt; data = new Stack&lt;Integer&gt;();    static Stack&lt;Integer&gt; min = new Stack&lt;Integer&gt;();    public static void push(int node) {        data.push(node);        if(min.isEmpty() || node&lt;min.peek()){            min.push(node);        }else{            min.push(min.peek());        }    }    public static void pop() {        min.pop();        data.pop();    }    public static int top() {        return data.peek();    }    public static int min() {        return min.peek();    }</code></pre><h3 id="16、栈的压入、弹出序列"><a href="#16、栈的压入、弹出序列" class="headerlink" title="16、栈的压入、弹出序列"></a>16、栈的压入、弹出序列</h3><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p></blockquote><ul><li><p>麻烦思路：新建一个堆栈，模拟入栈的情况，根据出栈的判断是否正确，逻辑上比较繁琐。1、判断是否相等且是否还能入栈‘’‘’‘’‘’‘</p><pre><code class="java">public boolean IsPopOrder(int [] pushA,int [] popA) {      int len = pushA.length;      Stack&lt;Integer&gt; data = new Stack&lt;Integer&gt;();      int i=0,j=0;      while(j&lt;len){          if (i&lt;len &amp;&amp; pushA[i] == popA[j]) {              i++;              j++;          }else if (data.isEmpty()){//入栈不等于出栈              data.push(pushA[i]);              i++;          }else if(data.peek() == popA[j]){                  data.pop();                  j++;          }else if(i &gt;= len-1){              return false;          }else{               data.push(pushA[i]);              i++;          }      }      return true;  }</code></pre></li><li><p>简单思路：没有必要对push进行验证，直接放进辅助栈即可，没放进去，都要进行循环比较辅助栈与pop的关系，这样清楚明了</p></li></ul><pre><code class="java">public static boolean IsPopOrder1(int [] pushA,int [] popA){        int len = pushA.length;        Stack&lt;Integer&gt; data = new Stack&lt;Integer&gt;();        for(int i=0,j=0;i&lt;len;i++){            data.push(pushA[i]);            while(!data.isEmpty() &amp;&amp; data.peek() == popA[j]){                data.pop();                j++;            }        }        return data.isEmpty();    }</code></pre><h3 id="17、复杂链表的复制"><a href="#17、复杂链表的复制" class="headerlink" title="17、复杂链表的复制"></a>17、复杂链表的复制</h3><blockquote><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p></blockquote><ul><li>思路：由于题目说不可以直接引用参数中的结点，所以不能直接遍历赋值；</li><li>分三步：1、将原有链表，每个节点后面加上相同元素，同时next值也复制；2、遍历复制后的，将random值也进行复制；3、遍历取出复制的部分</li></ul><pre><code class="java">public RandomListNode Clone(RandomListNode pHead)    {        if(pHead == null){            return null;        }        RandomListNode res = pHead;        while(res != null){            RandomListNode clone = new RandomListNode(res.label);            clone.next = res.next;            res.next = clone;            res = res.next.next;        }        res = pHead;        while(res!=null){            res.next.random = res.random == null? null:res.random.next;            res = res.next.next;        }        res = pHead;        RandomListNode c = pHead.next;        //就是把遍历每个，同时将他的next变为next.next        while(res.next != null){            RandomListNode cloneNode = res.next;            res.next = res.next.next;            res = cloneNode;        }        return c;    }</code></pre><h3 id="18、重建二叉树-2019-2-24"><a href="#18、重建二叉树-2019-2-24" class="headerlink" title="18、重建二叉树(2019.2.24)"></a>18、重建二叉树(2019.2.24)</h3><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><ul><li>思路：根据先序找到根节点，在中序中可知道左子树，右子树范围；再递归查找左子树的右子树的。</li></ul><pre><code class="java">public class Solution {    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {        return sort(pre,in,0,0,pre.length);    }    private static TreeNode sort(int[] pre,int[] in,int i,int j,int count){           if(count&gt;0){               int a=0;               for(;a&lt;count;a++){                   if(pre[i] == in[a+j])                       break;               }               TreeNode root = new TreeNode(pre[i]);               root.left = sort(pre,in,i+1,j,a);               root.right = sort(pre,in,i+a+1,j+a+1,count-a-1);               return root;           }            return null;        }}</code></pre><h3 id="19、树的子结构（类以与二叉查找树的后序遍历）"><a href="#19、树的子结构（类以与二叉查找树的后序遍历）" class="headerlink" title="19、树的子结构（类以与二叉查找树的后序遍历）"></a>19、树的子结构（类以与二叉查找树的后序遍历）</h3><blockquote><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p></blockquote><ul><li>思路：首先题意，如何判断是否为子结构，那么就对A遍历，找到值等于B的根节点（函数1），递归比较左右子树。</li><li>找到相等的，再去递归找B的left和right（函数2) ，其中对于空结点的判断是核心。</li></ul><pre><code class="java">public boolean HasSubtree(TreeNode root1,TreeNode root2) {        boolean result = false;        if(root1 != null &amp;&amp;root2 != null){            if(root1.val == root2.val){                result = isSubtree(root1,root2);            }            if(!result){                result = HasSubtree(root1.left,root2);            }            if(!result){                result = HasSubtree(root1.right,root2);            }        }        return result;    }    public boolean isSubtree(TreeNode root1,TreeNode root2){        if(root2 == null){            return true;        }        if(root1 == null){            return false;        }        if(root1.val!=root2.val){            return false;        }        return isSubtree(root1.left,root2.left) &amp;&amp; isSubtree(root1.right,root2.right);    }</code></pre><h3 id="20、二叉树的镜像"><a href="#20、二叉树的镜像" class="headerlink" title="20、二叉树的镜像"></a>20、二叉树的镜像</h3><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p></blockquote><ul><li>思路：递归。就是一直遍历从根节点开始将每个结点左右交换，遍历完就是镜像。不需要找到根节点之后再遍历。</li></ul><pre><code class="java"> public static void Mirror(TreeNode root) {        TreeNode temp = null;        if(root!=null){            temp = root.left;            root.left = root.right;            root.right = temp;            if(root.left != null)                Mirror(root.left);            if(root.right !=null)                Mirror(root.right);        }    }</code></pre><h3 id="21、从上往下打印二叉树"><a href="#21、从上往下打印二叉树" class="headerlink" title="21、从上往下打印二叉树"></a>21、从上往下打印二叉树</h3><blockquote><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><ul><li>思路：层次遍历，也是BFS，借助递归不好实现，转变思路，借用队列分容易实现。</li></ul></blockquote><pre><code class="java">public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) {        ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();        ArrayList&lt;TreeNode&gt; queue = new ArrayList&lt;TreeNode&gt;();        if(root == null){            return res;        }        queue.add(root);        while(!queue.isEmpty()){            TreeNode temp = queue.remove(0);            if(temp.left!=null)                queue.add(temp.left);            if(temp.right!=null)                queue.add(temp.right);            res.add(temp.val);        }        return res;    }</code></pre><h3 id="22、二叉搜索树的后序遍历序列"><a href="#22、二叉搜索树的后序遍历序列" class="headerlink" title="22、二叉搜索树的后序遍历序列"></a>22、二叉搜索树的后序遍历序列</h3><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><ul><li>思路：通过举例发现规律，根节点既末尾应该是前面值的分界线，可以通过这个判断，递归进行</li></ul><p>❌错误仅仅考虑了根节点与左右子树关系，没有考虑左右子树是否是二叉查找树</p><pre><code class="java">public boolean VerifySquenceOfBST(int [] sequence) {        int len = sequence.length;        if(len&lt;1){            return true;        }        int G = sequence[len-1],i=0;        for(;i&lt;len-1;i++){            if(sequence[i]&gt;G){                break;            }        }        int j =i;        for(;j&lt;len-1;j++){            if(sequence[j]&lt;G){                break;            }        }        if(j == len-1){            return true;        }else{            return false;        }    }</code></pre><p>正确✔（使用递归）</p><pre><code class="java">public boolean VerifySquenceOfBST(int [] sequence) {        int len = sequence.length;        if(len&lt;1){            return false;        }        return BST(sequence,0,len-1);    }    public boolean BST(int [] sequence,int x,int y){        if(y-x&gt;1){            int i=x,j;            for(;i&lt;y;i++){                if(sequence[i]&gt;sequence[y]){                    break;                }            }            j=i;            for(;j&lt;y;j++){                if(sequence[j]&lt;sequence[y]){                    return false;                }            }            return BST(sequence,x,i-1) &amp;&amp; BST(sequence,i,j-1);        }        return true;    }</code></pre><h3 id="23、二叉树中和为某一值的路径"><a href="#23、二叉树中和为某一值的路径" class="headerlink" title="23、二叉树中和为某一值的路径"></a>23、二叉树中和为某一值的路径</h3><blockquote><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p></blockquote><ul><li>思路：往下找直到根节点的和为目标值，相等且是根节点就加入res中，否则再去递归查找左子树右子树，最后还要删除该节点。</li></ul><pre><code class="java">ArrayList&lt;Integer&gt; R = new ArrayList&lt;Integer&gt;();    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) {        if(root == null){            return res;        }        find(root,target);        return res;    }    public void find(TreeNode root, int target){        R.add(root.val);        if(root.val == target &amp;&amp; root.left == null &amp;&amp; root.right == null){            res.add(new ArrayList&lt;&gt;(R));        }        if(root.left!=null){            find(root.left,target-root.val);        }        if(root.right!=null){            find(root.right,target-root.val);        }        R.remove(R.size()-1);    }</code></pre><h3 id="24、二叉搜索树与双向链表"><a href="#24、二叉搜索树与双向链表" class="headerlink" title="24、二叉搜索树与双向链表"></a>24、二叉搜索树与双向链表</h3><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p></blockquote><ul><li>思路：根据中序遍历进行变化，使用堆栈，先一直找左子树入栈，直到根节点。然后开始出栈，同时把右子树入栈。对于这道题就是需要在出栈时进行操作，出栈的数左指向前一个出栈的，前一个出栈右指该数，所以要知道前一个结点。</li></ul><pre><code class="java">public TreeNode Convert(TreeNode root){        TreeNode first = null;        if(root!=null){            Stack&lt;TreeNode&gt; temp = new Stack&lt;TreeNode&gt;();            TreeNode pre = null;            boolean flag = true;            while(!temp.isEmpty() || root!=null){                if(root!=null){                    temp.push(root);                    root = root.left;                }else{                    root = temp.pop();                    if(flag){                        first = root;                        pre = root;                        flag = false;                    }else{                        pre.right = root;                        root.left = pre;                        pre = root;                    }                    root = root.right;                }            }        }        return first;    }</code></pre><ul><li>使用递归法：同样也是用中序的递归，关键点在于获取链表的头结点，通过一个first变量。另外在对根节点操作的部分，需要改进，就是要让前面排好序的right指向现在的，现在left的指向以前的。</li></ul><pre><code class="java">TreeNode head = null;    TreeNode first = null;    public TreeNode Convert1(TreeNode root){        sub(root);        return first;    }    public void sub(TreeNode root){        if(root == null) return;        sub(root.left);        if(head == null){            first = root;            head = root;        }else{            root.left = head;            head.right = root;            head = root;        }        sub(root.right);    }</code></pre><h3 id="25、数组中出现次数超过一半的数字"><a href="#25、数组中出现次数超过一半的数字" class="headerlink" title="25、数组中出现次数超过一半的数字"></a>25、数组中出现次数超过一半的数字</h3><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p></blockquote><ul><li>思路：先排序，再查找时间复杂度高。选择O(n)的算法。<ol><li>通过快排的方法找到中位数，如果出现次数大于等于一半，肯定是中位数，再去判断是不是。</li></ol></li></ul><pre><code class="java">public static int MoreThanHalfNum_Solution(int[] array) {        int temp,len = array.length,start=0,end =len-1;        temp = getmid(array,start,end);        while (temp!=len/2){            if(temp&gt;len/2){                end = temp-1;                temp = getmid(array,start,end);            }else{                start = temp+1;                temp = getmid(array,temp+1,end);            }        }        if(check(array,array[temp]))            return array[temp];        else            return 0;    }    //    public static boolean check(int [] array,int num){        int len = array.length,time=0;        for(int i=0;i&lt;len;i++){            if(num == array[i])                time++;        }        if(time&gt;len/2)            return true;        else            return false;    }    public static int getmid(int [] num,int i,int j){        int temp = num[i];        while(i&lt;j){            while (i&lt;j &amp;&amp; temp&lt;=num[j]){                j--;            }            if(i&lt;j){                num[i] = num[j];            }            while (i&lt;j &amp;&amp; temp &gt;= num[i]){                i++;            }            if(i&lt;j){                num[j] = num[i];            }        }        num[i] = temp;        return i;    }</code></pre><ol start="2"><li>通过数组的特点，最简单方法，一个数字数组中出现次数大于len/2，则该数出现的次数一定是最多的，所以可以直接用两个变量来遍历完数组，找到可能是该数的数字。再去判断这个数是不是 </li></ol><pre><code class="java">//方法2    public static int MoreThanHalfNum_Solution1(int[] array) {        int len = array.length;        int temp=array[0],count=1,i,j;        for(i=1;i&lt;len;i++){            if(array[i-1] == array[i]){                count++;                temp = array[i];            }else if(count == 1){                temp = array[i];            }else{                count--;            }        }        if(check(array,temp))            return temp;        else            return 0;    }    //    public static boolean check(int [] array,int num){        int len = array.length,time=0;        for(int i=0;i&lt;len;i++){            if(num == array[i])                time++;        }        if(time&gt;len/2)            return true;        else            return false;    }</code></pre><ul><li>变形：找出大于1/3个数的，就是找出现次数最多的前两个，对于1/n的一样，找出次数最多的n-1个。只需要遍历一次即可</li></ul><pre><code class="java">//取出数组中不连续的值，达到1/3len个(排序之后)    public static ArrayList san(int [] a){        int len = a.length;        ArrayList list = new ArrayList();        int x=0,y=0;        int xnum=0,ynum=0;        for(int i =0;i&lt;len;i++){            if(xnum == 0||x==a[i]){                x = a[i];                ++xnum;            }else if(ynum == 0||y==a[i]){                y = a[i];                ++ynum;            }else{                xnum--;                ynum--;            }        }        if(check(x,a)){            list.add(x);        }        if(check(y,a)){            list.add(y);        }        return list;    }    public static boolean check(int x,int[] a) {        int num =0;        for(int i=0;i&lt;a.length;i++){            if(a[i] == x){                num++;            }        }        if(num&gt;a.length/3)            return true;        else            return false;    }//连续的更简单，就是遍历一次只用一个变量即可    public static ArrayList san1(int [] a){        int len = a.length;        ArrayList list = new ArrayList();        int x=0;        int xnum=0;        for(int i =0;i&lt;len;i++){            if(xnum == 0||x==a[i]){                x = a[i];                ++xnum;            }else{                if(xnum&gt;len/3){                    list.add(x);                    xnum=1;                    x=a[i];                }else{                    xnum=1;                    x=a[i];                }            }        }        return list;    }</code></pre><h3 id="26、最小的K个数"><a href="#26、最小的K个数" class="headerlink" title="26、最小的K个数"></a>26、最小的K个数</h3><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p></blockquote><ul><li>思路1：与用快排思路相似，找到位置为K-1的数字，同时前边都是小于他的，后边都是大于他的。（但是改变了原数组中元素位置）</li></ul><pre><code class="java">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) {        int len = input.length;        int start =0,end = len-1;        int temp = getmid(input,start,end);        ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();        if(len&lt;k || k&lt;=0 || len&lt;=0){            return res;        }        while(temp!=k-1){            if(temp&gt;k-1){                end = temp-1;                temp = getmid(input,start,end);            }else{                start = temp+1;                temp = getmid(input,start,end);            }        }        for(int i=0;i&lt;=temp;i++){            res.add(input[i]);        }        return res;    }    //核心算法，也是快排的重要    public int getmid(int [] array,int i,int j){        int temp = array[i];        while(i&lt;j){            if(i&lt;j &amp;&amp; temp&lt;=array[j]){                j--;            }            if(i&lt;j){                array[i] = array[j];            }            if(i&lt;j&amp;&amp;temp&gt;=array[i]){                i++;            }            if(i&lt;j){                array[j] = array[i];            }        }        array[i] = temp;        return i;    }</code></pre><ul><li>思路2（适合处理海量数据）堆排序：堆排序取出最大值O(1)，插入删除是O(logn)。每次比较堆排序的第一个，如果比他小，放进去，重新排序。最后得到的就是K个最小的。同理找K个最大的话，建立最小堆，比每次比较第一个，如果比他大则放进去。</li></ul><pre><code class="java">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) {        ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();        int len = input.length;        if(k&lt;1||len&lt;k){            return res;        }        int [] copy = new int[k];        for(int i=0;i&lt;k;i++){            copy[i] = input[i];        }        for(int x=k/2-1;x&gt;=0;x--){            sift(copy,x,k);        }        for(int i=k;i&lt;input.length;i++){            if(copy[0]&gt;input[i]){                copy[0] = input[i];                sift(copy,0,k);            }        }        for(int i=0;i&lt;k;i++){            res.add(copy[i]);        }        return res;    }    //构成最大堆    public  static void sift (int[] input,int low,int high){        int parent = low;        int temp = input[parent];        int child = 2*parent+1;        while(child&lt;high){            if(child&lt;high-1 &amp;&amp; input[child]&lt;input[child+1]){                child++;            }            if(temp&lt;input[child]){                input[parent] = input[child];                parent = child;                child = 2*parent+1;            }else{                break;            }        }        input[parent] = temp;    }</code></pre><h3 id="27、字符串的排列"><a href="#27、字符串的排列" class="headerlink" title="27、字符串的排列"></a>27、字符串的排列</h3><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><ul><li>全排列题目</li><li>思路1：递归法；回溯法；就是第一个数和后面所有数交换位置，然后再第二个数，一直递归。要注意遇到相同的直接跳过。举例就是{0与1交换，然后递归对2开始的后面数字做处理，最后把0与1再交换回来}，这是i++后的一次过程，交换回来才能对0跟2进行交换，否则可能是1和2交换。</li></ul></blockquote><pre><code class="java">    public static ArrayList&lt;String&gt; Permutation(String str) {        char [] s = str.toCharArray();        ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;();        if(s.length&gt;0 &amp;&amp; str!=null)            fullsort(s,0,ret);        Collections.sort(ret);        return ret;    }    public static void fullsort(char[] s,int begin,ArrayList&lt;String&gt; ret){        if(begin == s.length-1){            ret.add(String.valueOf(s));        }else{            Set&lt;Character&gt; chasrset = new HashSet&lt;Character&gt;();            for(int i = begin;i&lt;s.length;i++){                if(i==begin || !chasrset.contains(s[i])){                    chasrset.add(s[i]);                    swap(s,i,begin);                    fullsort(s,begin+1,ret);                    swap(s,begin,i);                }            }        }    }    public static void swap(char [] s,int i,int j){        char temp = s[i];        s[i] = s[j];        s[j] = temp;    }</code></pre><ul><li>思路2：非递归（字典序法）字典序就是按照字典的顺序，可以很容易比较两个数的大小，就是从头往后比较每一位的大小<blockquote><p> 一般而言，设P是[1,n]的一个全排列。<br>　　　　　　P=P1P2…Pn=P1P2…Pj-1PjPj+1…Pk-1PkPk+1…Pn<br>　　　　find:　　j=max{i|Pi&lt;Pi+1}<br>　　　　　　　　　k=max{i|Pi&gt;Pj}<br>　　　　　　1，  对换Pj，Pk，<br>　　　　　　2，  将Pj+1…Pk-1PjPk+1…Pn翻转</p><pre><code>      P’= P1P2…Pj-1PkPn…Pk+1PjPk-1…Pj+1即P的下一个</code></pre></blockquote></li></ul><pre><code class="java">public ArrayList&lt;String&gt; Permutation2(String str){        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();        if(str==null || str.length() == 0){            return list;        }        char [] temp = str.toCharArray();        Arrays.sort(temp);        list.add(String.valueOf(temp));        int len = temp.length;        while(true){            int lIndex = len-1;            int rIndex = 0;            while(lIndex&gt;=1&amp;&amp; temp[lIndex-1]&gt;=temp[lIndex]){                lIndex--;            }            if(lIndex == 0)                break;            rIndex = lIndex;            while(rIndex&lt;len &amp;&amp; temp[rIndex]&gt;temp[rIndex-1])                rIndex++;            swap(temp,lIndex-1,rIndex-1);            reverse(temp,lIndex);            list.add(String.valueOf(temp));        }        return list;    }    private void reverse(char[] chars,int k){        if(chars == null || chars.length&lt;=k){            return;        }        int len = chars.length;        for(int i =0;i&lt;(len-k)/2;i++){            int m = k+i;            int n = len-1-i;            if(m&lt;=n){                swap(chars,m,n);            }         }    }</code></pre><h3 id="30、连续子数组的最大和"><a href="#30、连续子数组的最大和" class="headerlink" title="30、连续子数组的最大和"></a>30、连续子数组的最大和</h3><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><ul><li>思路：不用考虑当前值，只用考虑前面的值的正负，如果是正的可以直接加当前值，如果是负的，直接把当前值赋给最大值。每次都要比较当前值与最大值的大小。</li></ul><pre><code class="java">public int FindGreatestSumOfSubArray(int[] array) {        int max=array[0],len=array.length,ret=array[0];        if(len == 0 || array == null)            return 0;        for(int i=1;i&lt;len;i++){            if(max&gt;=0){                max += array[i];            }else{                max = array[i];            }            if(max&gt;ret){                ret = max;            }        }        return ret;    }</code></pre><ul><li>思路2 动态规划：每一次前进要不是把这个值放入max里面，要不就是前面的都不要了。因此每次都是最大的话，肯定就能得到最大的值，同时每次还会记录当前结果的最大值</li></ul><pre><code class="java">public int FindGreatestSumOfSubArray1(int[] array) {        int max=array[0],len=array.length,ret=array[0];        if(len == 0 || array == null)            return 0;        for(int i=1;i&lt;len;i++){            max = Math.max(max+array[i],array[i]);            ret = Math.max(ret,max);        }        return ret;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日头条后端笔试题（2018.12刷）</title>
      <link href="/2019/03/07/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%882018.12%E5%88%B7%EF%BC%89/"/>
      <url>/2019/03/07/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%882018.12%E5%88%B7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="2018年12月参加头条武汉open-day（后台）"><a href="#2018年12月参加头条武汉open-day（后台）" class="headerlink" title="2018年12月参加头条武汉open day（后台）"></a>2018年12月参加头条武汉open day（后台）</h1><ol><li>有2，3，5，三种硬币，输入每个硬币的个数，和要凑够的钱数，求最少需要的硬币球</li><li>演唱会，有n个歌手，开始时间s，结束时间e，求最多可听几场，结束时间不可以等于下一场开始时间。</li><li>一个点餐系统，包括菜品的导入删除上架下架，顾客点餐及查看订单状态，餐厅查看订单内容，热门商品查询</li></ol><h2 id="分硬币问题："><a href="#分硬币问题：" class="headerlink" title="分硬币问题："></a>分硬币问题：</h2><p>贪心算法得到是局部最优解</p><p>*</p><h2 id="动态规划法求解"><a href="#动态规划法求解" class="headerlink" title="动态规划法求解"></a>动态规划法求解</h2><p>*</p><h2 id="最大映射（今日头条2017笔试）"><a href="#最大映射（今日头条2017笔试）" class="headerlink" title="最大映射（今日头条2017笔试）"></a>最大映射（今日头条2017笔试）</h2><blockquote><p>有 n 个字符串，每个字符串都是由 A-J 的大写字符构成。现在你将每个字符映射为一个 0-9<br>的数字，不同字符映射为不同的数字。这样每个字符串就可以看做一个整数，唯一的要求是这些整数必须是正整数且它们的字符串不能有前导零。现在问你怎样映射字符才能使得这些字符串表示的整数之和最大？</p><p>输入描述:  每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n ， 接下来有 n 行，每行一个长度不超过 12 且仅包含大写字母<br>A-J 的字符串。 n 不大于 50，且至少存在一个字符不是任何字符串的首字母。</p><p>输出描述:  输出一个数，表示最大和是多少。</p><p>输入例子:  2  ABC  BCA</p><p>输出例子:  1875</p></blockquote><blockquote><p>输入多行数据 input input</p></blockquote><pre><code># -*- coding: utf-8 -*-def test():    i = int(input())    a = []    num = 9    s = 0    first = set()    ans = {&#39;A&#39;:0, &#39;B&#39;:0, &#39;C&#39;:0, &#39;D&#39;:0, &#39;E&#39;:0, &#39;F&#39;:0, &#39;G&#39;:0, &#39;H&#39;:0, &#39;I&#39;:0, &#39;J&#39;:0}    for x in range(i):        a.append(input())    for y in a:        l = len(y)        for z in y:            if l == len(y):                first.add(z)                    ans[z] += 10**(l-1)            l -= 1    #对dict,按value进行排序    ans1 = sorted(ans.items(),key = lambda d:d[1],reverse = True)#对于排好序的数组ans1，如果最后一个在first里面，就要跟倒数第二个调换，类推      ans2 = []    for i in range(10):        ans2.append(list(ans1[i]))    if (ans2[9][0] in first):        for i in range(8,-1,-1):            if (ans2[i][0] not in first):                ans2[i][1] = -1                break    ans1 = sorted(ans2,key = lambda d:d[1],reverse = True)       for i in range(10):        ans[ans1[i][0]] = num        num -= 1    for x in a:        l = len(x)        for y in x:            s += 10**(l-1)*ans[y]            l -= 1    print(s)if __name__ == &#39;__main__&#39;:    test()            </code></pre><h2 id="木棒拼图"><a href="#木棒拼图" class="headerlink" title="木棒拼图"></a>木棒拼图</h2><blockquote><p>有一个由很多木棒构成的集合，每个木棒有对应的长度，请问能否用集合中的这些木棒以某个顺序首尾相连构成一个面积大于 0<br>的简单多边形且所有木棒都要用上，简单多边形即不会自交的多边形。</p><p>初始集合是空的，有两种操作，要么给集合添加一个长度为 L<br>的木棒，要么删去集合中已经有的某个木棒。每次操作结束后你都需要告知是否能用集合中的这些木棒构成一个简单多边形。</p><p>输入描述: 每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n 表示操作的数量(1 ≤ n ≤ 50000) ，<br>接下来有n行，每行第一个整数为操作类型 i (i ∈ {1,2})，第二个整数为一个长度 L(1 ≤ L ≤<br>1,000,000,000)。如果 i=1 代表在集合内插入一个长度为 L 的木棒，如果 i=2 代表删去在集合内的一根长度为 L<br>的木棒。输入数据保证删除时集合中必定存在长度为 L 的木棒，且任意操作后集合都是非空的。</p><p>输出描述: 对于每一次操作结束有一次输出，如果集合内的木棒可以构成简单多边形，输出 “Yes” ，否则输出 “No”。</p><p>输入例子1: 5 1 1 1 1 1 1 2 1 1 2</p><p>输出例子1: No No Yes No No</p></blockquote><pre><code>def test2():    i = int(input())    a = []    q = 0    for m in range(i):        x = input().split()         if(x[0] == &#39;1&#39;):            a.append(int(x[1]))        if(x[0] == &#39;2&#39;):            a.remove(int(x[1]))        print(test21(a))def test21(x):    l = len(x)    q = 0    x.sort(reverse =False)    for n in range(l-1):        q += x[n]    if q &gt; x[l-1]:         return &#39;Yes&#39;        else:        return &#39;No&#39;if __name__ == &#39;__main__&#39;:    test2()            </code></pre><p>ac</p><h2 id="回文解码"><a href="#回文解码" class="headerlink" title="回文解码"></a>回文解码</h2><blockquote><p>现在有一个字符串，你要对这个字符串进行 n 次操作，每次操作给出两个数字：(p, l) 表示当前字符串中从下标为 p 的字符开始的长度为 l<br>的一个子串。你要将这个子串左右翻转后插在这个子串原来位置的正后方，求最后得到的字符串是什么。字符串的下标是从 0<br>开始的，你可以从样例中得到更多信息。</p><p>输入描述: 每组测试用例仅包含一组数据，每组数据第一行为原字符串，长度不超过 10 ，仅包含大小写字符与数字。接下来会有一个数字 n 表示有<br>n 个操作，再接下来有 n 行，每行两个整数，表示每次操作的(p , l)。</p><p>保证输入的操作一定合法，最后得到的字符串长度不超过 1000。</p><p>输出描述: 输出一个字符串代表最后得到的字符串。</p><p>输入例子1: ab 2 0 2 1 3</p><p>输出例子1: abbaabb</p></blockquote><pre><code>def fanzhuan(s):    l = len(s)    for i in range(l//2):        s[i],s[l-1-i] = s[l-1-i],s[i]       return sdef test1():    s = list(input())    n = int(input())    for i in range(n):#0存放开始位置，1存放旋转的长度        tab = input().split()        a = int(tab[0])        b = int(tab[1])        ss = fanzhuan(s[a:(a+b)])        s = s[:(a+b)]+ss+s[(a+b):]    print(&#39;&#39;.join(s))</code></pre><h2 id="出专辑"><a href="#出专辑" class="headerlink" title="出专辑"></a>出专辑</h2><blockquote><p>你作为一名出道的歌手终于要出自己的第一份专辑了，你计划收录 n 首歌而且每首歌的长度都是 s 秒，每首歌必须完整地收录于一张 CD<br>当中。每张 CD 的容量长度都是 L 秒，而且你至少得保证同一张 CD 内相邻两首歌中间至少要隔 1 秒。为了辟邪，你决定任意一张 CD<br>内的歌数不能被 13 这个数字整除，那么请问你出这张专辑至少需要多少张 CD ？</p><p>输入描述: 每组测试用例仅包含一组数据，每组数据第一行为三个正整数 n, s, L。 保证 n ≤ 100 , s ≤ L ≤ 10000 </p><p>输出描述: 输出一个整数代表你至少需要的 CD 数量。</p><p>输入例子1: 7 2 6</p><p>输出例子1: 4</p></blockquote><ul><li>核心在于最后一张cd数如果是13的余数的处理：<br>1-如果每张cd里的歌曲数比最后一张多一个，此时倒数第二张分给最后一张一首歌，无法满足，只能再增加一个cd<br>2-如果倒数第二张不是比最后的多一个，那么说明它减去一个也不会整除13，最后一个加上一个也不会超出限制 </li></ul><pre><code>def test2():    i = input().split()    n = int(i[0])    s = int(i[1])    L = int(i[2])    cd = L//(s+1)    if L%(s+1) == s:        cd += 1        cd = min(n,cd)    if cd%13 == 0:        cd -= 1# cd get percd song    cdsum = n//cd    if n%cd != 0:        cdsum += 1        if (n%cd)%13 == 0 and cd-(n%cd) == 1:            cdsum += 1    print(cdsum)</code></pre><h2 id="用户喜好"><a href="#用户喜好" class="headerlink" title="用户喜好"></a>用户喜好</h2><blockquote><p>为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1&lt;=L2&lt;=R2&lt;=R1)。</p><p>输入描述: 输入： 第1行为n代表用户的个数 第2行为n个整数，第i个代表用户标号为i的用户对某类文章的喜好度<br>第3行为一个正整数q代表查询的组数<br>第4行到第（3+q）行，每行包含3个整数l,r,k代表一组查询，即标号为l&lt;=i&lt;=r的用户中对这类文章喜好值为k的用户的个数。 数据范围n<br>&lt;= 300000,q&lt;=300000 k是整型</p><p>输出描述: 输出：一共q行，每行一个整数代表喜好值为k的用户的个数</p><p>输入例子1: 5 1 2 3 3 5 3 1 2 1 2 4 5 3 5 3</p><p>输出例子1: 1 0 2</p><p>例子说明1: 样例解释: 有5个用户，喜好值为分别为1、2、3、3、5， 第一组询问对于标号[1,2]的用户喜好值为1的用户的个数是1<br>第二组询问对于标号[2,4]的用户喜好值为5的用户的个数是0 第三组询问对于标号[3,5]的用户喜好值为3的用户的个数是2</p></blockquote><ul><li><p>傻瓜算法，记录所有输入喜爱程度，在遍历每次查找的要求中，再对所有的喜爱程度进行遍历，满足情况的加1   时间复杂度O(n2)</p></li><li><p>将喜爱程度记录在dict中，相同的序号放在一起，这样直接查找喜爱程度的复杂度O(1)<br>然后在该喜爱程度的序号中找到满足要求的个数 ，通过二分法找到其中满足的</p></li></ul><pre><code>def test3():    num = int(input())    people = input().split()    people = [int(i) for i in people]    like = {}    for i in range(len(people)):        if people[i] in like:            like[people[i]].append(i)        else:            like[people[i]] = [i]         time = int(input())    for i in range(time):        n = 0        ask = input().split()        ask = [int(i) for i in ask]        a = ask[0]        b = ask[1]        c = ask[2]        if c not in like:            print(0)        else:            for j in like[c]:                if(j&gt;=a-1 and j&lt;b):                    n += 1            print(n)if __name__ == &#39;__main__&#39;:    test3()    </code></pre><p><a href="https://blog.csdn.net/flushhip/article/details/79261608" target="_blank" rel="noopener">二分法的处理</a></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kaggle 入门 泰坦尼克 处理过程</title>
      <link href="/2019/03/07/kaggle%20%E5%85%A5%E9%97%A8%20%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%20%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/03/07/kaggle%20%E5%85%A5%E9%97%A8%20%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%20%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据预处理"><a href="#一、数据预处理" class="headerlink" title="一、数据预处理"></a>一、数据预处理</h2><ol><li>pandas库的内容（数据分析处理）：<ul><li>read_csv   ：读取文件，变为矩阵</li></ul></li></ol><ul><li><p>head(n) : 输出前n行内容，默认5</p><pre><code>PassengerId  Survived  Pclass  \0            1         0       3   1            2         1       1   2            3         1       3                                                 Name     Sex   Age  SibSp  \0                            Braund, Mr. Owen Harris    male  22.0      1   1  Cumings, Mrs. John Bradley (Florence Briggs Th...  female  38.0      1   2                             Heikkinen, Miss. Laina  female  26.0      0    Parch            Ticket     Fare Cabin Embarked  0      0         A/5 21171   7.2500   NaN        S  1      0          PC 17599  71.2833   C85        C  2      0  STON/O2. 3101282   7.9250   NaN        S </code></pre></li><li><p>describe() : 对特征值进行描述</p><pre><code>     PassengerId    Survived      Pclass         Age       SibSp  \count   891.000000  891.000000  891.000000  714.000000  891.000000   mean    446.000000    0.383838    2.308642   29.699118    0.523008   std     257.353842    0.486592    0.836071   14.526497    1.102743   min       1.000000    0.000000    1.000000    0.420000    0.000000   25%     223.500000    0.000000    2.000000   20.125000    0.000000   50%     446.000000    0.000000    3.000000   28.000000    0.000000   75%     668.500000    1.000000    3.000000   38.000000    1.000000   max     891.000000    1.000000    3.000000   80.000000    8.000000             Parch        Fare  count  891.000000  891.000000  mean     0.381594   32.204208  std      0.806057   49.693429  min      0.000000    0.000000  25%      0.000000    7.910400  50%      0.000000   14.454200  75%      0.000000   31.000000  max      6.000000  512.329200  </code></pre></li><li><p>info()  ： 每个特征值有多少项，是否有缺失值及数据类型</p></li></ul><pre><code>RangeIndex: 891 entries, 0 to 890Data columns (total 12 columns):PassengerId    891 non-null int64Survived       891 non-null int64Pclass         891 non-null int64Name           891 non-null objectSex            891 non-null objectAge            714 non-null float64SibSp          891 non-null int64Parch          891 non-null int64Ticket         891 non-null objectFare           891 non-null float64Cabin          204 non-null objectEmbarked       889 non-null objectdtypes: float64(2), int64(5), object(5)memory usage: 83.6+ KBNone</code></pre><ul><li>数据填充<br>fillna(  )  ： 将空白的数据进行填充 <pre><code>train[&#39;Age&#39;] = train[&#39;Age&#39;].fillna(train[&#39;Age&#39;].median)train[&#39;Embarked&#39;] = train[&#39;Embarked&#39;].fillna(&#39;S&#39;)</code></pre><ul><li>字符变数字<br>定位函数 loc   ：定位特征值等于XX的行，某个特征值=？<br>loc——通过行标签索引行数据<br>iloc——通过行号索引行数据 （a，b）a代表行，b代表列<br>ix——通过行标签或者行号索引行数据（基于loc和iloc 的混合）<pre><code>train.loc[train[&#39;Sex&#39;]==&#39;male&#39;,&#39;Sex&#39;] = 0train.loc[train[&#39;Sex&#39;]==&#39;female&#39;,&#39;Sex&#39;] = 1</code></pre></li></ul></li></ul><p>train.loc[train[‘Embarked’]==’S’,’Embarked’] = 0<br>train.loc[train[‘Embarked’]==’C’,’Embarked’] = 1<br>train.loc[train[‘Embarked’]==’Q’,’Embarked’] = 2</p><pre><code>## 二、数据图表处理### 1.将各特征值用图标显示![在这里插入图片描述](https://img-blog.csdnimg.cn/20181109144731761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70) -  获救人数300多人，不到一半 -  三等舱人最多，二等舱人最少 -  获救与否，人的年龄分布广泛 -  舱位等级越高，年龄普遍越大 -  上船位置排序，S&gt;C&gt;Q### 2.查看舱位等级、性别与获救人数关系![在这里插入图片描述](https://img-blog.csdnimg.cn/20181112102910299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/2018111210302234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70)- 头等舱的获救比例明显高很多- 获救人数中女性比例明显高很多### 3.性别+等级![在这里插入图片描述](https://img-blog.csdnimg.cn/20181112102216162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70)- 同第二个相同### 4.登船口与获救关系![](https://img-blog.csdnimg.cn/20181112102004810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70)- 获救人数S&gt;C&gt;Q### 5.堂兄弟妹、孩子父母 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181112104453480.png)         ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181112104354521.png)### 6.统计 Cabin - 缺失值较多，800个人只有147个有，考虑统计是否有cabin</code></pre><p>C23 C25 C27        4<br>B96 B98            4<br>G6                 4<br>F33                3<br>F2                 3<br>D                  3<br>C22 C26            3<br>E101               3<br>D17                2<br>C83                2<br>B58 B60            2<br>C65                2<br>C78                2<br>E24                2<br>C2                 2<br>B18                2<br>B35                2<br>C68                2<br>。。。。。。。<br>E46                1<br>A32                1<br>C128               1<br>Name: Cabin, Length: 147, dtype: int64</p><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20181112110452239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70)- 可以看出有这个属性的人获救比例更高## 三、特征工程1. 缺失值处理：（根据数据的info属性，得到age、cabin缺失最多）- 如果缺值的样本占总数比例极高，我们可能就直接舍弃了，作为特征加入的话，可能反倒带入noise，影响最后的结果了- 如果缺值的样本适中，而该属性非连续值特征属性(比如说类目属性)，那就把NaN作为一个新类别，加到类别特征中- 如果缺值的样本适中，而该属性为连续值特征属性，有时候我们会考虑给定一个step(比如这里的age，我们可以考虑每隔2/3岁为一个步长)，然后把它离散化，之后把NaN作为一个type加到属性类目中。（把age属性作为类目属性）- 有些情况下，缺失的值个数并不是特别多，那我们也可以试着根据已有的值，拟合一下数据，补充上。2. 用scikit-learn中的RandomForest（随机森林）来补充Age中的缺失值用&#39;Fare&#39;, &#39;Parch&#39;, &#39;SibSp&#39;, &#39;Pclass属性，来预测age。将完好的数据，数值型的特征输入RFR进行fit；然后将缺失age的样本其他特征输入获得age</code></pre><p>def miss_age(df):<br>    # 把已有的数值型特征取出来丢进Random Forest Regressor中<br>    age_df = df[[‘Age’,’Fare’, ‘Parch’, ‘SibSp’, ‘Pclass’]]<br>    # 乘客分成已知年龄和未知年龄两部分<br>    known_age = age_df[age_df.Age.notnull()].as_matrix()<br>    unknown_age = age_df[age_df.Age.isnull()].as_matrix()<br><br>    # y即目标年龄([x,y]表示x取全部，y只取第一位)<br>    y = known_age[:, 0]<br>    # X即特征属性值<br>    X = known_age[:, 1:]<br><br>    # fit到RandomForestRegressor之中<br>    rfr = RandomForestRegressor(random_state=0, n_estimators=2000, n_jobs=-1)<br>    rfr.fit(X, y)<br><br>    # 用得到的模型进行未知年龄结果预测<br>    predictedAges = rfr.predict(unknown_age[:, 1:])<br>    # 用得到的预测结果填补原缺失数据<br>    df.loc[ (df.Age.isnull()), ‘Age’ ] = predictedAges<br><br>    return df, rfr</p><pre><code>3. 将所有特征改为数值型离散特征的编码分为两种情况：- 离散特征的取值之间没有大小的意义，比如color：[red,blue],那么就使用one-hot编码利用pandas中的get_dummies 对离散特征进行编码&gt; 有一篇教学直接这些属性用数字0，1，2，3代替，其实是不严谨的，因为本来他只是一个属性没有数值意义，数字使他们有了大小区分，这跟将每个特征的属性作为一个特征，得到的模型肯定不一样，精确度应该也是one-hot更好。pandas.get_dummies(data, prefix=None, prefix_sep=&#39;_&#39;, dummy_na=False, columns=None, sparse=False, drop_first=False)</code></pre><p>data : array-like, Series, or DataFrame<br>输入的数据<br>prefix : string, list of strings, or dict of strings, default None<br>get_dummies转换后，列名的前缀<br>*columns : list-like, default None<br>指定需要实现类别转换的列名<br>dummy_na : bool, default False<br>增加一列表示空缺值，如果False就忽略空缺值<br>drop_first : bool, default False<br>获得k中的k-1个类别值，去除第一个</p><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/20181113103155941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70)- 离散特征的取值有大小的意义，比如size:[X,XL,XXL],那么就使用数值的映射{X:1,XL:2,XXL:3}</code></pre><p>df = pd.DataFrame([<br>            [‘green’, ‘M’, 10.1, ‘class1’],<br>            [‘red’, ‘L’, 13.5, ‘class2’],<br>            [‘blue’, ‘XL’, 15.3, ‘class1’]])  </p><p>df.columns = [‘color’, ‘size’, ‘prize’, ‘class label’]<br>size_mapping = {<br>           ‘XL’: 3,<br>           ‘L’: 2,<br>           ‘M’: 1}<br>df[‘size’] = df[‘size’].map(size_mapping)  </p><pre><code>- 然后再将更改后的数据加入到原数据中：（用concat函数）</code></pre><p>pd.concat(objs, axis=0, join=’outer’, join_axes=None, ignore_index=False,keys=None, levels=None, names=None, verify_integrity=False)<br>1， axis=0, 对行操作    axis=1， 对列操作</p><ol start="2"><li>join=’outer’, 连接各个数据    join=’inner’,只取各个数据的公共部分</li><li>join_axes=[df1.index], 保留与df1的行标签一样的数据，配合axis=1一起用<br>join_axes=[df1.columns]，保留与df1的列标签一样的数据，不要添加axis=1</li><li>ignore_index=False, 保留原索引    ignore_index=True,忽略原索引并生成新索引</li><li>keys=[‘x’, ‘y’, ‘z’] 对组成的每个df重新添加个索引<pre><code></code></pre></li></ol><p>运行代码之后得到如图所示：</p><pre><code>#将数据转化为数值型dummies_Cabin = pd.get_dummies(train[&#39;Cabin&#39;], prefix= &#39;Cabin&#39;)dummies_Embarked = pd.get_dummies(train[&#39;Embarked&#39;], prefix= &#39;Embarked&#39;)dummies_Sex = pd.get_dummies(train[&#39;Sex&#39;], prefix= &#39;Sex&#39;) dummies_Pclass = pd.get_dummies(train[&#39;Pclass&#39;], prefix= &#39;Pclass&#39;)df = pd.concat([train, dummies_Cabin, dummies_Embarked, dummies_Sex, dummies_Pclass], axis=1)#axis 删除列；inplace代表删除后直接替换该值df.drop([&#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Ticket&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], axis=1, inplace=True)</code></pre><p><img src="https://img-blog.csdnimg.cn/20181113130928831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="4"><li>特征归一化：（sklearn.preprocessing.StandardScaler() ====scaler）</li></ol><pre><code>#归一化import sklearn.preprocessing as preprocessingscaler = preprocessing.StandardScaler()#age_scale_param = scaler.fit(df[&#39;Age&#39;].values.reshape(-1,1))df[&#39;Age_scaled&#39;] = scaler.fit_transform(df[&#39;Age&#39;].values.reshape(-1,1))#fare_scale_param = scaler.fit(df[&#39;Fare&#39;].values.reshape(-1,1))df[&#39;Fare_scaled&#39;] = scaler.fit_transform(df[&#39;Fare&#39;].values.reshape(-1,1))</code></pre><p>被调用的方法<br>fit(X,y=None):计算输入数据各特征的平均值，标准差已经之后的缩放系数<br>X 为array 或者 稀疏矩阵，[样本数量，样本特征数]<br>y: 传入为了使得和Pipeline兼容<br>就可以直接查询相关系数，scale.mean_</p><p>scale_： 缩放比例，同时也是标准差<br>mean_： 每个特征的平均值<br>var_:每个特征的方差<br>n_sample_seen_:样本数量，可以通过patial_fit 增加</p><p>fit_transform(X,y=None,**fit_params): 通过fit_params调整数据X,y得到一个调整后的X<br>X 为array：训练集<br>y 为标签<br>返回一个改变后的X</p><h2 id="四、逻辑回归建模"><a href="#四、逻辑回归建模" class="headerlink" title="四、逻辑回归建模"></a>四、逻辑回归建模</h2><p>LogisticRegression(C=1.0, penalty=’l1’, tol=1e-6)</p><ul><li>penalty：惩罚项，str类型，可选参数为l1和l2，默认为l2。用于指定惩罚项中使用的规范。newton-cg、sag和lbfgs求解算法只支持L2规范。L1G规范假设的是模型的参数满足拉普拉斯分布，L2假设的模型参数满足高斯分布，所谓的范式就是加上对参数的约束，使得模型更不会过拟合(overfit)，但是如果要说是不是加了约束就会好，这个没有人能回答，只能说，加约束的情况下，理论上应该可以获得泛化能力更强的结果。</li><li>c：正则化系数λ的倒数，float类型，默认为1.0。必须是正浮点型数。像SVM一样，越小的数值表示越强的正则化。</li><li>tol：停止求解的标准，float类型，默认为1e-4。就是求解到多少的时候，停止，认为已经求出最优解<br><a href="https://blog.csdn.net/jark_/article/details/78342644" target="_blank" rel="noopener">参数详解</a></li></ul><pre><code>from sklearn import linear_modeltrain_df = df.filter(regex=&#39;Survived|Age_.*|SibSp|Parch|Fare_.*|Cabin_.*|Embarked_.*|Sex_.*|Pclass_.*&#39;)train_np = train_df.as_matrix()y = train_np[:,0]X = train_np[:,1:]clf = linear_model.LogisticRegression(C=1.0, penalty=&#39;l1&#39;, tol=1e-6)clf.fit(X,y)</code></pre><h2 id="五、小结："><a href="#五、小结：" class="headerlink" title="五、小结："></a>五、小结：</h2><p>以上为baseling的结果，只是对数据进行了处理，并且直接放入逻辑回归模型中，参数也没有进行调整；一共10个特征，提取的特征只有（Age_.<em>|SibSp|Parch|Fare_.</em>|Cabin_.<em>|Embarked_.</em>|Sex_.<em>|Pclass_.</em>）8个<br>（查看数据info等选取特征值、缺失值少的随机森林填补，缺失多的可以将是否缺失作为一个特征、特征进行onehot处理（get_dummies）、范围大的数值型数据进行归一化处理、训练集放入逻辑回归中、测试集同样处理后predict）<br><img src="https://img-blog.csdnimg.cn/20181114214300495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="六、进阶"><a href="#六、进阶" class="headerlink" title="六、进阶"></a>六、进阶</h2><ol><li>猜测：</li></ol><ul><li>name、ticket 属性没有用，主要是数据共同点少</li><li>预测的年龄值可能并不准确，毕竟年龄与其他属性不一定有什么关系，而且年龄大的和小的理论最容易获救，所以这个关系应该不是线性的</li></ul><ol start="2"><li>查看逻辑回归系数（系数越大正相关，负即位负相关）<pre><code>a = pd.DataFrame({&quot;columns&quot;:list(train_df.columns)[1:], &quot;coef&quot;:list(clf.coef_.T)})print(a)              coef      columns0   [-0.344235547502]        SibSp1   [-0.104916059432]        Parch2               [0.0]     Cabin_No3    [0.902108372278]    Cabin_Yes4               [0.0]   Embarked_C5               [0.0]   Embarked_Q6   [-0.417264091571]   Embarked_S7     [1.95657115809]   Sex_female8    [-0.67742062132]     Sex_male9    [0.341158456052]     Pclass_110              [0.0]     Pclass_211   [-1.19413034174]     Pclass_312  [-0.523766665956]   Age_scaled13  [0.0844348218785]  Fare_scaled</code></pre>SibSp、Parch：略微的负相关<br>Cabin：有的更容易获救<br>Embarked：影响不大<br>sex :  female影响明显<br>Pclass ：1舱使获救升高，3舱大大降低<br>Age：负相关，年龄越小越好<br>Fare：很小的正相关</li></ol><p>3.交叉验证（cross validation） </p><ul><li>cross_val_score（测试集进行循环5次交叉验证）</li></ul><pre><code>sklearn.cross_validation.cross_val_score(estimator, X, y=None, scoring=None, cv=None, n_jobs=1, verbose=0, fit_params=None, pre_dispatch=‘2*n_jobs’)estimator：数据对象 X：数据 y：预测数据 soring：调用的方法cv：交叉验证生成器或可迭代的次数 n_jobs：同时工作的cpu个数（-1代表全部）verbose：详细程度fit_params：传递给估计器的拟合方法的参数pre_dispatch：控制并行执行期间调度的作业数量。减少这个数量对于避免在CPU发送更多作业时CPU内存消耗的扩大是有用的。该参数可以是：</code></pre><pre><code>from sklearn import cross_validationclf = linear_model.LogisticRegression(C=1.0, penalty=&#39;l1&#39;, tol=1e-6)xcross = train_np[:,1:]ycross = train_np[:,0]print(cross_validation.cross_val_score(clf, xcross, ycross, cv=5))</code></pre><p>通过交叉验证，训练集分成5份，然后4分作为训练集，1份作为测试集，检验训练模型的结果，输出为：<br>[0.81564246 0.81005587 0.78651685 0.78651685 0.81355932]</p><ul><li>train_test_split（将矩阵随机划分为训练子集和测试子集，并返回划分好的训练集测试集样本和训练集测试集标签。）查看那些预测错的案例<pre><code>X_train,X_test, y_train, y_test =cross_validation.train_test_split(train_data,train_target,test_size=0.3, random_state=0)参数解释：</code></pre></li></ul><p>train_data：被划分的样本特征集</p><p>train_target：被划分的样本标签</p><p>test_size：如果是浮点数，在0-1之间，表示样本占比；如果是整数的话就是样本的数量</p><p>random_state：是随机数的种子。</p><p>随机数种子：其实就是该组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如你每次都填1，其他参数一样的情况下你得到的随机数组是一样的。但填0或不填，每次都会不一样。<br>随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则：种子不同，产生不同的随机数；种子相同，即使实例不同也产生相同的随机数。</p><pre><code>将数据按训练集、测试集 7：3分开，然后训练出的模型，预测结果与真实比较，查看预测错的案例</code></pre><p>split_train, split_cv = cross_validation.train_test_split(df, test_size=0.3, random_state=0)<br>train_df0 = split_train.filter(regex=’Survived|Age_.<em>|SibSp|Parch|Fare_.</em>|Cabin_.<em>|Embarked_.</em>|Sex_.<em>|Pclass_.</em>‘)</p><h1 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h1><p>clf = linear_model.LogisticRegression(C=1.0, penalty=’l1’, tol=1e-6)<br>clf.fit(train_df0.as_matrix()[:,1:], train_df0.as_matrix()[:,0])</p><h1 id="对cross-validation数据进行预测"><a href="#对cross-validation数据进行预测" class="headerlink" title="对cross validation数据进行预测"></a>对cross validation数据进行预测</h1><p>cv_df = split_cv.filter(regex=’Survived|Age_.<em>|SibSp|Parch|Fare_.</em>|Cabin_.<em>|Embarked_.</em>|Sex_.<em>|Pclass_.</em>‘)<br>predictions = clf.predict(cv_df.as_matrix()[:,1:])</p><p>origin_data_train = pd.read_csv(“train.csv”)<br>bad_cases = origin_data_train.loc[origin_data_train[‘PassengerId’].isin(split_cv[predictions != cv_df.as_matrix()[:,0]][‘PassengerId’].values)]</p><pre><code>通过对错误案例的分析，来对特征工程进行改进，再进行验证## sklearn 模型选择(https://scikit-learn.org/stable/index.html)- KFLOD（用于交叉验证的函数。在机器学习中，样本量不充足时，通常使用交叉训练验证）—— 将A分为K等份，1个最为测试集，其他作为训练集KFold(n_splits=3, shuffle=False, random_state=None) n_splits：表示划分几等份shuffle：在每次划分时，是否进行洗牌①若为Falses时，其效果等同于random_state等于整数，每次划分的结果相同②若为True时，每次划分的结果都不一样，表示经过洗牌，随机取样的random_state：随机种子数KFold(n, n_folds=3, shuffle=False, random_state=None)n为总数n_folds为分为多少个交叉验证集shuffle为是否随机random_state设置随机因子 - 线性回归、逻辑回归 直接输入fit（特征值，lable值）然后predict（训练集特征值）</code></pre><pre><code>#线性回归from sklearn.linear_model import LinearRegression#交叉验证from sklearn.cross_validation import KFoldalg.fit(tr_pre,tr_tar)#te行的所有列te_pre = (train[predictors].iloc[te,:])te_tar = alg.predict(te_pre)</code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode(10月)</title>
      <link href="/2018/11/27/Leetcode%20%20%20(10%E6%9C%88)/"/>
      <url>/2018/11/27/Leetcode%20%20%20(10%E6%9C%88)/</url>
      
        <content type="html"><![CDATA[<h1 id="10月份"><a href="#10月份" class="headerlink" title="10月份"></a>10月份</h1><h2 id="01题TWO-SUM（10-6）"><a href="#01题TWO-SUM（10-6）" class="headerlink" title="01题TWO SUM（10.6）"></a>01题TWO SUM（10.6）</h2><p><img src="https://img-blog.csdn.net/201810061348522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="所示"></p><ul><li>python暴力法<br>报错运行时间超时，时间复杂度O(n^2)，空间复杂度O(1)<pre><code>l = len(nums)      for i in range(l):          if nums[i] &gt; target :              continue          if i == l-1 :              return &#39;error&#39;          for j in range(i+1,l):              if nums[i]+nums[j] == target :                  return [i,j]</code></pre></li><li>python一遍哈希表，时间O(n)，空间O(n)</li></ul><pre><code>def twoSum(nums, target):    d = {}    for i, n in enumerate(nums):        if n in d:            return [d[n], i]        else:            d[target-n]=i    return (0,0)</code></pre><p>因为没有查找value的方法，所以创建一个value-key 的dict，其中的d[target-num[i]] = i，在创建哈希表的同时就可以查找，找到键对应值的就为第一个数的位置</p><ul><li>Java 一遍哈希表<br>Map接口<br>boolean containsKey(Object k)<br>如果此映射包含指定键的映射关系，则返回 true<br>Object get(Object k)<br>返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</li></ul><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();        for(int i = 0;i&lt;nums.length;i++){            int b = target - nums[i];            if(map.containsKey(b)){                return new int[] {map.get(b),i};            }            map.put(nums[i],i);        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre><p><a href="https://blog.csdn.net/CLHugh/article/details/75000104" target="_blank" rel="noopener">Python 中self 用法</a><br>主要是用于类中定义函数方便调用</p><h2 id="02题Add-Two-Numbers（10-9）"><a href="#02题Add-Two-Numbers（10-9）" class="headerlink" title="02题Add Two Numbers（10.9）"></a>02题Add Two Numbers（10.9）</h2><blockquote><p>You are given two non-empty linked lists representing two non-negative<br>integers. The digits are stored in reverse order and each of their<br>nodes contain a single digit. Add the two numbers and return it as a<br>linked list.</p><p>You may assume the two numbers do not contain any leading zero, except<br>the number 0 itself.</p><p>Example:</p><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation:<br>342 + 465 = 807.</p></blockquote><p>这道题学习到了链表的操作，Java和python中利用引用，定义类来实现链表等数据结构的操作</p><ul><li>python麻烦的</li></ul><pre><code> def addTwoNumbers(self, l1, l2):        &quot;&quot;&quot;        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        &quot;&quot;&quot;        #进位                cur = 0        item = z = ListNode(0)        a = l1.val + l2.val        cur = a//10        item.next = ListNode(a%10)               item =item.next        #巧妙的对z进行操作实现链表，下一个对应一个链        while l1.next and l2.next:            l1 = l1.next            l2 = l2.next            a = l1.val + l2.val            b = a%10 + cur            item.next = ListNode(b%10)            cur = a//10+b//10            item = item.next                    if l1.next == None and l2.next == None :            if cur&gt;0:                item.next = ListNode(cur)            return z.next                 elif l1.next == None:            while l2.next:                l2 = l2.next                a = l2.val                b = a + cur                item.next = ListNode(b%10)                cur = b//10                item = item.next            if cur&gt;0:                item.next = ListNode(cur)            return z.next        elif l2.next == None:            while l1.next:                l1 = l1.next                a = l1.val                b = a + cur                item.next = ListNode(b%10)                cur = b//10                item = item.next            if cur&gt;0:                item.next = ListNode(cur)            return z.next</code></pre><ul><li>python别人的</li></ul><pre><code>class Solution:    def addTwoNumbers(self, l1, l2):        &quot;&quot;&quot;        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        &quot;&quot;&quot;        temp = z = ListNode(0)        cur = 0        while l1 or l2 or cur:            if l1:                cur +=l1.val                l1 = l1.next            if l2:                cur +=l2.val                l2 = l2.next            temp.next = ListNode(cur%10)            temp = temp.next            cur //=10            return z.next   </code></pre><ul><li>Java的</li></ul><pre><code> public ListNode addTwoNumbers(ListNode l1, ListNode l2) {            ListNode z = new ListNode(0);            ListNode p = l1,q = l2,temp = z;            int cur = 0;            while(p!=null || q!=null) {                int x = (p!=null)? p.val:0;                int y = (q!=null)? q.val:0;                int sum = x+y+cur;                cur = sum/10;                temp.next = new ListNode(sum%10);                temp = temp.next;                if(p!=null) {                    p = p.next;                }                if(q!=null) {                    q = q.next;                }        }            if(cur&gt;0) {                temp.next = new ListNode(cur);            }        return z.next;}</code></pre><ul><li><a href="https://www.cnblogs.com/qlshine/p/6049457.html" target="_blank" rel="noopener">Python定义类的几种方法总结：</a><br> 1__init__()，用于初始化一个类<h2 id="03题（10-10）Longest-Substring-Without-Repeating-Characters"><a href="#03题（10-10）Longest-Substring-Without-Repeating-Characters" class="headerlink" title="03题（10.10）Longest Substring Without Repeating Characters"></a>03题（10.10）Longest Substring Without Repeating Characters</h2></li><li>python暴力（超时）<br>对于每一个函数的任务要明确，算法思想要少漏洞<pre><code>def lengthOfLongestSubstring(s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; max = 0 for i in range(len(s)):     for j in range(i+1,len(s)+1):         if isSubstring(s,i,j):             length = j-i             if(length&gt;max):                 max = length return max</code></pre></li></ul><p>def isSubstring(s,i,j):<br>    for m in range(i,j):<br>        if s[m] in s[m+1:j]:<br>            return False<br>    return True</p><pre><code>- python滑动窗口</code></pre><pre><code>def lengthOfLongestSubstring(self, s):    &quot;&quot;&quot;    :type s: str    :rtype: int    &quot;&quot;&quot;    a = &#39;&#39;    j =0    max = 0    n = len(s)    while(j&lt;n):        if(s[j] not in a):            a = a+s[j]            j = j+1            if(max&lt;len(a)):                max = len(a)        else:            a = a[1::]       return max      </code></pre><pre><code>- python优化的滑动窗口</code></pre><p>a = {}<br>        j = 0<br>        ans = 0<br>        for i in range(len(s)):<br>            if(s[i] in a):<br>                j = max(a[s[i]],j)<br>            a[s[i]] = i+1<br>            ans = max(ans,i-j+1)<br>        return ans</p><pre><code>## 04题Median of Two Sorted Arrays（10.13）m个 num1  i处分开    n个 num2   j处分开1、i + j =m-i +n - j(或：m-i+n-j+1)      n&gt;m  j = (m+n+1)/22、A[i-1]&lt;=b[j]  b[j-1]&lt;=A[i]二叉树搜索：    imin=0，imax= m,i = (imin+imax)/2    </code></pre><p>def findMedianSortedArrays(self, A, B):<br>        “””<br>        :type nums1: List[int]<br>        :type nums2: List[int]<br>        :rtype: float<br>        “””<br>        m = len(A)<br>        n = len(B)<br>        if m&gt;n:<br>            A,B,m,n = B,A,n,m<br>        if n == 0:<br>            return error<br>        imin = 0<br>        imax = m<br>        x = (m+n+1)//2<br>        while(imin&lt;=imax):<br>            i = (imin+imax)//2<br>            j = x-i<br>            if i&lt;m and B[j-1]&gt;A[i] :<br>                imin = i+1<br>            elif i&gt;0 and  A[i-1]&gt;B[j]:<br>                imax = i-1<br>            else:<br>                if i == 0: maxleft = B[j-1]<br>                elif j == 0: maxleft =A[i-1]<br>                else : maxleft = max(A[i-1],B[j-1])</p><pre><code>            if(m+n)%2 == 1:                return maxleft            if i == m: minright = B[j]            elif j == n: minright = A[i]            else: minright = min(A[i],B[j])            return (maxleft+minright)/2.0</code></pre><pre><code>## 05题Longest Palindromic Substring- 中心扩展算法：从回文的中心开始找，对所有字符遍历，中心有两种可能：单个字符，以及挨着的相等字符               时间O（n2）</code></pre><p>def longestPalindrome(self, s):<br>        “””<br>        :type s: str<br>        :rtype: str<br>        “””<br>        n = len(s)<br>        start,end = 0,0<br>        for i in range(n):<br>            len1 = self.palindromic(s,i,i)<br>            len2 = self.palindromic(s,i,i+1)<br>            L = max(len1,len2)<br>            if(L&gt;end-start):<br>                start = i - (L-1)//2<br>                end = i + L//2<br>        return s[start:end+1]</p><pre><code>def palindromic(self,s,i,j):    L,R = i,j    while(L&gt;=0 and R&lt;len(s) and s[L] == s[R]):        L -= 1        R += 1    return R-L-1</code></pre><pre><code>- **Manacher 算法**时间复杂度O（N）的专门解决回文的算法     1. 算法分析由于回文分为奇偶回文，处理比较麻烦，在每个字符前后都加上一个符号，从而变成奇数</code></pre><p>s =‘abcd’      变为   s = ‘#a#b#c#d’</p><pre><code>回文具有对称性质，pal（i）以i为中心的最大回文半径![在这里是图片描述](https://img-blog.csdn.net/20181018100339753?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)图中为以id为中心的回文，mx是回文的边界，我们想要得到以i为中心的最大回文半径，可以通过对j（i关于id的对称点）求解得到   ------j = 2*id - i</code></pre><p>if(i&lt;mx)<br>    p[i] = min(p[2<em>id-i],mx-i)<br>    若 p[2</em>id-i] == mx-i<br>        i还可以再往两边增加</p><pre><code>以上通过P[j]，可以快速得到对称的回文数，减少时间复杂度 2. 马拉车代码</code></pre><p>class Solution:<br>    def longestPalindrome(self,s):<br>        ss = ‘’                     #装入加了#号的新字符串<br>        for i in s:<br>            ss = ss+’#’<br>            ss = ss+i<br>        ss = ss+’#’<br>        p = [0]*2001                #表示以i为中心的最长回文字符串半径<br>        start,end,maxlen,mx = 0,0,0,0  #mx是以id为中心的回文最右边，start end最长的开始和结束</p><pre><code>    for i in range(len(ss)):        if(i&lt;mx):                     p[i] = min(p[2*id-i],mx-i)       #如果在id回文的边界之内，则可以借鉴对称位置的值        else:            p[i] = 1        while((i - p[i])&gt;=0 and i+p[i]&lt;len(ss) and ss[i-p[i]] == ss[i+p[i]]):   #在已知基础上看还有没有其他值            p[i] += 1        if(mx&lt;i+p[i]):                      #更新id和mx            id = i            mx = i+p[i]        if(maxlen&lt;(p[i]-1)):               #如果最大长度替换原来的            maxlen = p[i]-1            start = i+1-p[i]            end = i+p[i]-1    return ss[start:end+1].replace(&#39;#&#39;,&#39;&#39;)</code></pre><pre><code>## 10、Container With Most Water（10.19）暴力法python  o（n2）超时</code></pre><p>m = 0<br>        long = len(height)<br>        for i in range(long-1):<br>            for j in range(i+1,long):<br>                high = min(height[i],height[j])<br>                s = (j-i)*high<br>                if(m&lt;s): m = s<br>        return m</p><pre><code>由两边向中心</code></pre><pre><code>def maxArea(self, height):    end = len(height)-1    start = 0    max = 0    while(start&lt;end):        s = (end-start)*min(height[start],height[end])        if(max&lt;s): max = s        if(height[start]&lt;height[end]):            start += 1        else:             end -=1    return max</code></pre><pre><code>## 15.3SUM（10.20）思路：简单的暴力法肯定会超时换思路，先排序（通过排序解决重复问题），选出一个数后取反-c，如果遇到相等的直接跳过，然后从右边剩下的里面找a,b,从两边向中间找，a如果相等直接跳过，直到a+b = -c</code></pre><p>def threeSum(self, nums):<br>        “””<br>        :type nums: List[int]<br>        :rtype: List[List[int]]<br>        “””<br>        l,ans = len(nums),[]<br>        nums.sort()<br>        for i in range(l-2):<br>            if i &gt; 0 and nums[i] == nums[i-1]:<br>                continue<br>            c = nums[i]*-1<br>            a = i+1<br>            b = l-1<br>            while a&lt;b :<br>                if nums[a]+nums[b] == c:<br>                    ans.append([nums[i],nums[a],nums[b]])<br>                    a += 1<br>                    while a&lt;b and nums[a] == nums[a-1]:<br>                        a += 1<br>                elif nums[a] + nums[b] &lt; c :<br>                    a += 1<br>                else:<br>                    b -= 1<br>        return ans</p><pre><code>## 17.Letter Combinations of a Phone Number(10.21-11.8)思路：通过输入的数字，得到要输出的key值——num，循环遍历num，将对应的value相加两个数组相加最简单，多个数组很难操作通过新建一个空数组的方式，循环进行两数组相加 - python</code></pre><pre><code>n = len(digits)    phone = {2:&#39;abc&#39;,3:&#39;def&#39;,4:&#39;ghi&#39;,5:&#39;jkl&#39;,6:&#39;mno&#39;,7:&#39;pqrs&#39;,8:&#39;tuv&#39;,9:&#39;wxyz&#39;}    res = [&#39;&#39;]    if n == 0:        return []    for i in digits:        num = phone[int(i)]          newres = []        for a in num:            for b in res:                newres.append(b+a)        res = newres    return res</code></pre><pre><code>- java一样思路的解法（其中java直接赋值是将地址给了）</code></pre><p>public List<string> letterCombinations(String digits) {<br>        List<string> ans = new ArrayList<string>();<br>        List<string> newans = new ArrayList<string>();<br>        String[] mapping = new String[] {“0”, “1”, “abc”, “def”, “ghi”, “jkl”, “mno”, “pqrs”, “tuv”, “wxyz”};<br>        if(digits.isEmpty()) return ans ;<br>        ans.add(“”);<br>        for(int i=0;i&lt;digits.length();i++) {<br>            int x = Character.getNumericValue(digits.charAt(i));<br>            newans.clear();<br>            for(char s : mapping[x].toCharArray())<br>                {<br>                    for(String t: ans) {<br>                        newans.add(t+s);<br>                    }<br>                }<br>            ans.clear();<br>            ans.addAll(newans);<br>        }<br>        return ans;<br>    }</string></string></string></string></string></p><pre><code>- java另一个思路remove(),直接去掉第一个元素并取出，一直循环直到所有的元素都加上了新的</code></pre><p>public static List<string> letterCombinations(String digits) {<br>        LinkedList<string> ans = new LinkedList<string>();<br>        String[] mapping = new String[] {“0”, “1”, “abc”, “def”, “ghi”, “jkl”, “mno”, “pqrs”, “tuv”, “wxyz”};<br>        if(digits.isEmpty()) return ans ;<br>        ans.add(“”);<br>        for(int i=0;i&lt;digits.length();i++) {<br>            int x = Character.getNumericValue(digits.charAt(i));<br>            while(ans.peek().length()==i){<br>                String t = ans.remove();<br>                for(char s : mapping[x].toCharArray())<br>                    ans.add(t+s);<br>            }<br>        }<br>        return ans;</string></string></string></p><pre><code>}</code></pre><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/28/hello-world/"/>
      <url>/2018/07/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git上发布hexo框架下的博客</title>
      <link href="/2018/07/28/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2018/07/28/%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><ol><li>安装node，npm,通过cmd可以看出来是否安装成功</li></ol><p>node(前端框架)<br>npm(随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题)<br><img src="https://img-blog.csdnimg.cn/201907281453589.png" alt></p><ul><li>接下来安装cnpm 速度更块是淘宝做的国内镜像<br>通过输入命令行(npm install -g cnpm -registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>)<br><img src="https://img-blog.csdnimg.cn/20190728151844338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt></li></ul><ol start="2"><li>安装hexo框架<br>执行语句完成安装 cnpm install -g hexo-cli<br><img src="https://img-blog.csdnimg.cn/20190728152314927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt></li><li>新建一个文件夹用来存放生成的blog文件</li></ol><h2 id="二、hexo相关操作"><a href="#二、hexo相关操作" class="headerlink" title="二、hexo相关操作"></a>二、hexo相关操作</h2><ol><li>执行(hexo init)，初始化hexo环境,需要较长时间</li></ol><p>安装时会卡在npm install loadAllDepsIntoIdealTree<br>因为npm还是通过原有地址进行下载，需要修改成镜像地址</p><pre><code>修改npm config set registry https://registry.npm.taobao.org查看npm config get registry </code></pre><p>看到以下说明初始化成功<br><img src="https://img-blog.csdnimg.cn/20190728164515889.png" alt></p><ol start="2"><li>启动(hexo s)</li></ol><p>即可看到自己的博客</p><ol start="3"><li><pre><code>常用命令hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #部署到GitHubhexo help  # 查看帮助hexo version  #查看Hexo的版本缩写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy</code></pre></li></ol><h2 id="三、发布到Github上"><a href="#三、发布到Github上" class="headerlink" title="三、发布到Github上"></a>三、发布到Github上</h2><ol><li>自己的github上新建一个仓库</li></ol><ol start="2"><li><p>安装hexo的git插件<br>cnpm install hexo-deployer-git –save</p></li><li><p>修改_config.yml 文件，里面是配置信息<br>最后一行修改<br><img src="https://img-blog.csdnimg.cn/20190728170102707.png" alt></p></li><li><p>命令hexo d，发布到git仓库</p></li><li><p>直接连接 <a href="https://zqfang666.github.io/">https://zqfang666.github.io/</a>  进入博客</p></li></ol><h2 id="四、博客美化"><a href="#四、博客美化" class="headerlink" title="四、博客美化"></a>四、博客美化</h2><ol><li>_config.yml 文件的信息</li></ol><pre><code>#博客名称title: 我的博客#副标题subtitle: 一天进步一点#简介description: 记录生活点滴#博客作者author: lxq#博客语言language: zh-CN#时区timezone:#博客地址,与申请的GitHub一致url: http://elfwalk.github.ioroot: /#博客链接格式permalink: :year/:month/:day/:title/permalink_defaults:source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:  enable: true  line_number: true  auto_detect: true  tab_replace:default_category: uncategorizedcategory_map:tag_map:#日期格式date_format: YYYY-MM-DDtime_format: HH:mm:ss#分页，每页文章数量per_page: 10pagination_dir: page#博客主题theme: landscape#发布设置deploy:   type: git  #elfwalk改为你的github用户名  repository: https://github.com/elfwalk/elfwalk.github.io.git  branch: maste</code></pre><ol start="2"><li>通过   git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia   命令，来克隆主题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode（11月）</title>
      <link href="/2018/01/08/leetcode%EF%BC%8811%E6%9C%88%EF%BC%89/"/>
      <url>/2018/01/08/leetcode%EF%BC%8811%E6%9C%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>leetcode（11月）<br>2道</p><h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19.Remove Nth Node From End of List"></a>19.Remove Nth Node From End of List</h1><blockquote><p>Given a linked list, remove the n-th node from the end of list and return its head.</p><p>Example:</p><p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p><p>After removing the second node from the end, the linked list becomes<br>1-&gt;2-&gt;3-&gt;5. Note:</p><p>Given n will always be valid.</p><p>Follow up:</p><p>Could you do this in one pass?</p></blockquote><p> 题意：对于一个链表删除倒数第n个数后，输出链表</p><ul><li>Java 先计算长度，找到删除元素的正数位置，再进行删除操作</li></ul><pre><code class="java">public ListNode removeNthFromEnd(ListNode head, int n) {       ListNode z = head;          ListNode a = new ListNode(0);        ListNode y,b = new ListNode(0);        b.next = head ;        y = b;        int m =0;        while(z != null){            z=z.next;            m++;        }        m = m -n+1;        for(int i = 0;i&lt;m;i++){            a = y;            y = y.next;        }        a.next = y.next;                return b.next;    }</code></pre><ul><li>牛🍺的思路：fast点先移动到n+1位置，再和slow点一起移动，直到fast点到最后，此时slow点就是要删除的点</li></ul><pre><code class="java">    ListNode start = new ListNode(0);        start.next = head;        ListNode slow = start,fast = head;              for(int i =0;i&lt;n;i++){            fast = fast.next;        }        while(fast != null){            fast = fast.next;            slow = slow.next;        }        slow.next = slow.next.next;        return start.next;</code></pre><ul><li>python </li></ul><pre><code class="python">def removeNthFromEnd(self, head, n):        &quot;&quot;&quot;        :type head: ListNode        :type n: int        :rtype: ListNode        &quot;&quot;&quot;        fast = head        slow = start = ListNode(0)        slow.next = head        start.next = head        for i in range(n):            fast = fast.next        while(fast):            fast = fast.next            slow = slow.next        slow.next = slow.next.next        return start.next</code></pre><h1 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h1><blockquote><p>Given an input string (s) and a pattern(p),<br>implement regular expression matching with support for ‘.’ and ‘<em>‘.<br>‘.’ Matches any single character. ‘</em>‘ Matches zero or more of the preceding element.<br>The matching should cover the entire input string(not partial).</p></blockquote><p>思路：输入一个字符串s，p由正则表达式组成，. 任意字符   * 代表出现&gt;=0<br>对字符串进行遍历，</p><h1 id="MARK-改变思路专题练习"><a href="#MARK-改变思路专题练习" class="headerlink" title="MARK 改变思路专题练习"></a>MARK 改变思路专题练习</h1><p><img src="https://img-blog.csdnimg.cn/20190108170725211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MDY0NjM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Leetcode%20%E9%A2%98%E8%A7%A3.md#%E5%8F%8C%E6%8C%87%E9%92%88" target="_blank" rel="noopener">大佬Leetcode刷题TAG</a></p><h1 id="Eclpse查看源码"><a href="#Eclpse查看源码" class="headerlink" title="Eclpse查看源码"></a>Eclpse查看源码</h1><p>Ctrl+鼠标左键，这个常用语查看变量、类型及方法的定义以及查看方法的实现<br>Ctrl+O，这个用于查看一个类的纲要，列出其方法和成员变量，再按一次时，列出该类继承的方法及变量。<br>Ctrl+T，这个用于查看一个类的继承关系树，是自顶向下的结构显示，再按一次会变成自底向上，同时列出所实现的接口；当这个快捷键使用在方法上时，会列出有同名方法的父类、子类和接口。<br>Alt+左右方向键，阅读代码时，我们经常进入调用的方法查看后又跳转回调用的位置，Ctrl+左方向键是退回上一个阅读的位置，Ctrl+右方向键是前进到下一个阅读 的位置。<br>Ctrl+Alt+H，这个用于显示方法被哪些方法调用，并生成调用树。<br>Ctrl+L，这个用于跳转到指定的行</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
